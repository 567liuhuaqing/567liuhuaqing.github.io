[{"content":" C++和Java一样是基于面向对象的（面向过程和面向对象混编 —— 因为C++兼容C），关注的是类对象以及对象间的关系，将一件事情拆分成不同的对象，靠对象之间的交互完成，体现到代码层面就是类的设计及类的关系\nthis指针 类的引入 C++兼容了C中结构体的用法，同时struct在C++中也升级成了类\nC++类和结构体不同的是，除了可以定义变量，还可以定义方法/函数\n用结构体定义的学生类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include\u0026lt;string.h\u0026gt; #include\u0026lt;iostream\u0026gt; using namespace std; struct Student { //成员变量，加_是为了区分 char _name[20]; int _age; //成员函数/方法 void Init(const char* name, int age) { strcpy(_name, name); _age = age; } void Print() { cout \u0026lt;\u0026lt; _name \u0026lt;\u0026lt; \u0026#34; \u0026#34; \u0026lt;\u0026lt; _age \u0026lt;\u0026lt; endl; } }; int main() { struct Student s1;\t//C++兼容C Student s2;\t//可以这样写，Student是类名，也是类型 s1.Init(\u0026#34;小边\u0026#34;, 19);\t//成员函数采用内平栈 s1.Print();\t//函数传参时，会默认传this指针 s2.Init(\u0026#34;王巨龙\u0026#34;, 19); s2.Print(); return 0; } 对于上面结构体的定义，C++中更喜欢用class来代替\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 class Date { public: void Init(int year, int month, int day)\t{ _year = year; _month = month; _day = day; } void Print() { cout \u0026lt;\u0026lt; _year \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; _month \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; _day \u0026lt;\u0026lt; endl; } private: // 这⾥只是声明，没有开空间 int _year; int _month; int _day; }; 调用约定* C++新的调用约定__thiscall\n32位系统（x86） 类成员函数：通常使用 __thiscall 约定\nthis 指针通过 ECX 寄存器 传递 其他参数从右向左压栈 被调用函数负责清理栈 64位系统（x64） 统一使用 快速调用约定： this 指针作为隐含的第一个参数，通过 RCX 寄存器 传递 前4个参数使用寄存器（RCX, RDX, R8, R9），其余压栈 调用者负责清理栈空间 类的访问限定符和封装 封装 众所周知，【面向对象的三大特性】：封装、继承、多态\n在类和对象阶段，我们只研究类的封装特性，什么是封装？\n把属性和方法都封装到一个类里面 访问限定符 —— 可以给其他类访问的成员定义成公有，不想被其他类访问的成员定义成私有/保护 访问限定符* C++实现封装的方式，用类将对象的属性和方法结合在一起，让对象更加完善，通过访问权限选择性的将其接口提供给外部的用户使用\n公有：public修饰的成员所以类均可访问 私有和保护：private修饰的成员仅类内部访问，protected类内部和子类可访问 class的默认访问权限为private，struct的为public（因为struct要兼容C） —— 一般定义类的时候，建议明确访问修饰限定符，不要指着class/struct默认限定符 访问权限的作用域从这个访问限定符出现的位置开始，到下一个访问限定符出现为止 类的定义* 类定义了一个新的作用域。类的所有成员都在类的作用域中；在类外定义成员，需要::作用解析符指明成员属于哪个类域。\n我们可以在头文件中声明一个类，并在.cpp文件中定义类\nmystack.h\n1 2 3 4 5 6 7 8 9 10 11 12 13 #pragma once class Stack { public: void stackInit(); void stackPush(int x); void stackPop(); int stackTop(); private: int* _a; int _top; int _capacity; }; mytest.cpp\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include \u0026lt;cassert\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026#34;mystack.h\u0026#34; using namespace std; void Stack::stackInit() { _a = (int*)malloc(sizeof(int) * 10); _top = _capacity = 0; } void Stack::stackPush(int x) { _a[_top++] = x; } void Stack::stackPop() { _top--; } int Stack::stackTop() { assert(_top \u0026gt; 0); return _a[_top - 1]; } int main() { Stack st;\t//对象示例化（栈上分配）和Java不同，不需要new st.stackInit(); st.stackPush(1); int a = st.stackTop(); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; /*下面是指针实现（堆上分配） Stack* st = new Stack; st-\u0026gt;stackInit(); st-\u0026gt;stackPush(1); int a = st-\u0026gt;stackTop(); cout \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; */ } 类及对象大小 我们用下面代码查看（64位编译器指针为8B，32位为4B）\n1 2 cout \u0026lt;\u0026lt; sizeof(Stack) \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; sizeof(st) \u0026lt;\u0026lt; endl; 计算类的对象的大小 —— 只看成员变量，且要考虑内存对齐，C++内存对齐规则和C一样\n注意，空类比较特殊，编译器给了空类一个字节来标识这个类。不存储有效数据，只是为了空间占位，标识对象存在 内存对齐 可以通过#pragma pack(n)来设定变量以n字节对齐方式\n类对象的存储：和Java一样，C++只保存成员变量，成员函数放在公共的代码段\n第一个成员在与结构体偏移量为0的地址处。\n其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。\n注意：对齐数 = 编译器默认的一个对齐数 与 该成员大小的较小值。（VS中默认的对齐数为8）\n结构体总大小为：最大对齐数（所有变量类型最大者与默认对齐参数取最小）的整数倍。\n如果嵌套了结构体的情况，嵌套的结构体对齐到自己的最大对齐数的整数倍处，结构体的整体大小就是所有最大对齐数（含嵌套结构体的对齐数）的整数倍。\n类成员函数的this指针 先定义一个日期类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 class Date{ public:\tvoid InitDate(int year,int month,int day) {\t_year = year;\t//隐含this指针\t_month = month;\t//相当于this-\u0026gt;_month = month _day = day;\t}\tvoid PrintDate() { cout \u0026lt;\u0026lt; _year \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; _month \u0026lt;\u0026lt; \u0026#34;-\u0026#34; \u0026lt;\u0026lt; _day \u0026lt;\u0026lt; endl;\t} private:\tint _year;\tint _month;\tint _day; }; int main() { Date d1;\tDate d2;\td1.InitDate(2003, 10, 13);\td2.InitDate(2005, 06, 07); d1.PrintDate();\t//这里都会传入Data* const this参数 d2.PrintDate();\t//相当于\u0026amp;d2 return 0; } C++通过引入this指针：C++编译器给每个“非静态的成员函数”增加了一个隐藏的指针参数，让该指针指向当前对象(函数运行时调用该函数的对象)，在函数体中所有成员变量的操作，都是通过该指针去访问，只不过所有的操作对用户是透明的，即用户不需要来传递，编译器自动完成，this指针本身不能被修改\n类的默认成员函数 任何一个类即使是空类，都会自动生成下面6个默认成员函数，这就是C++比较复杂的初始化机制\n构造函数* 构造函数是特殊的成员函数。注意，构造函数的虽然名称叫构造，但是构造函数的主要任务并不是开空间创建对象**，而是**初始化对象\n构造函数特点\n函数名和类名相同 无返回值 对象实例化时，编译器自动调用对应的构造函数 构造函数可以重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Date { public: //1.无参构造函数 Date() { _year = 0; _month = 1; _day = 1; } //2.带参构造函数 - 初始化成指定值 Date(int year, int month, int day) { _year = year; _month = month; _day = day; } private: int _year; int _month; int _day; }; int main() { //对象实例化时，自动调用 Date d1;\t//调用无参构造函数 Date d2(2003, 10, 13); return 0; } 但是如果在类中没有写构造函数，则编译器会默认生成一个无参构造函数\n默认构造函数有三种 —— 无参构造函数、全缺省构造函数、编译器默认生成的构造函数，而一个类只能有一个\n析构函数* 与构造函数功能相反，对象在销毁时会自动调用析构函数，完成对象的一些资源清理工作\n析构函数特点\n析构函数名是在类名前加上字符~ 无参数无返回值 一个类只能有一个析构函数，不能重载 对象生命周期结束时，编译器自动调用析构函数 同样以Data类为例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class Date { public: Date(int year = 2005, int month = 6, int day = 7) {\t//全缺省构造函数 _year = year; _month = month; _day = day; } ~Date() { cout \u0026lt;\u0026lt; \u0026#34;~Date()\u0026#34; \u0026lt;\u0026lt; endl; } private: int _year; int _month; int _day; }; int main() { Date d1; return 0; } 当然，该类中的成员都是在栈上的，不需要清理资源；若有数组成员（在堆上分配空间），则需要析构函数了，比如前面实现的栈类\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 class Stack { public: Stack(int capacity = 4) {\t//构造函数 _a = (int*)malloc(sizeof(int)* capacity); if (_a == nullptr) { cout \u0026lt;\u0026lt; \u0026#34;malloc failed\u0026#34; \u0026lt;\u0026lt; endl; exit(-1); } _top = 0; _capacity = capacity; } ~Stack() {\t//析构函数 free(_a); _a = nullptr; _top = _capacity = 0; } private: int* _a; int _top; int _capacity; }; int main() { Stack st1; Stack st2(20); return 0; } 注意：若是struct | class这种自定义类型，不需要实现析构函数，编译器默认生成\n拷贝构造函数 运算符重载* 运算符重载（Operator Overloading）是 C++ 中允许程序员重新定义已有运算符的行为，使其适用于自定义类型（类或结构体）的特性。这使得自定义类型可以像内置类型一样使用运算符，提高代码的可读性和自然性\n运算符重载的基本规则\n不能创建新运算符：只能重载 C++ 中已有的运算符 不能改变运算符优先级：重载后运算符的优先级不变 不能改变操作数个数：单目运算符只能有一个操作数，双目运算符两个 至少有一个操作数是用户定义类型 部分运算符不能重载：::, .*, ., ?:, sizeof, typeid 两种实现方式 成员函数形式 1 2 3 4 5 6 7 8 9 10 11 12 13 class Complex { double real, imag; public: Complex(double r, double i) : real(r), imag(i) {} // 成员函数形式重载+ Complex operator+(const Complex\u0026amp; other) const {\t//隐含参数\tthis 指针（指向左操作数） return Complex(real + other.real, imag + other.imag); } }; Complex a(1, 2), b(3, 4); Complex c = a + b; // 等价于 a.operator+(b) 非成员函数形式（常为友元） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Complex { double real, imag; public: Complex(double r, double i) : real(r), imag(i) {} // 声明友元函数 friend Complex operator+(const Complex\u0026amp; a, const Complex\u0026amp; b); }; // 非成员函数实现 Complex operator+(const Complex\u0026amp; a, const Complex\u0026amp; b) { return Complex(a.real + b.real, a.imag + b.imag); } Complex c = a + b; // 等价于 operator+(a, b) 常用运算符重载实例 算术运算符：+, -, *, / 1 2 3 4 5 6 7 8 9 10 11 12 13 class Fraction { int num, den; // 分子分母 public: Fraction(int n, int d) : num(n), den(d) {} Fraction operator+(const Fraction\u0026amp; other) const { return Fraction(num * other.den + other.num * den, den * other.den); } friend Fraction operator*(const Fraction\u0026amp; a, const Fraction\u0026amp; b) { return Fraction(a.num * b.num, a.den * b.den); } }; 比较运算符：==, !=, \u0026lt;, \u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 class Date { int year, month, day; public: bool operator==(const Date\u0026amp; other) const { return year == other.year \u0026amp;\u0026amp; month == other.month \u0026amp;\u0026amp; day == other.day; } bool operator\u0026lt;(const Date\u0026amp; other) const { if (year != other.year) return year \u0026lt; other.year; if (month != other.month) return month \u0026lt; other.month; return day \u0026lt; other.day; } }; 流运算符：\u0026lt;\u0026lt;, \u0026gt;\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Student { std::string name; int id; public: friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const Student\u0026amp; s) { return os \u0026lt;\u0026lt; \u0026#34;ID: \u0026#34; \u0026lt;\u0026lt; s.id \u0026lt;\u0026lt; \u0026#34;, Name: \u0026#34; \u0026lt;\u0026lt; s.name; } friend std::istream\u0026amp; operator\u0026gt;\u0026gt;(std::istream\u0026amp; is, Student\u0026amp; s) { std::cout \u0026lt;\u0026lt; \u0026#34;Enter ID: \u0026#34;; is \u0026gt;\u0026gt; s.id; std::cout \u0026lt;\u0026lt; \u0026#34;Enter name: \u0026#34;; is \u0026gt;\u0026gt; s.name; return is; } }; Student s; std::cin \u0026gt;\u0026gt; s; std::cout \u0026lt;\u0026lt; s; 下标运算符：[] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class IntArray { int* data; size_t size; public: IntArray(size_t s) : size(s), data(new int[s]) {} ~IntArray() { delete[] data; } // 可修改版本 int\u0026amp; operator[](size_t index) { if (index \u0026gt;= size) throw std::out_of_range(\u0026#34;Index out of range\u0026#34;); return data[index]; } // const版本 const int\u0026amp; operator[](size_t index) const { if (index \u0026gt;= size) throw std::out_of_range(\u0026#34;Index out of range\u0026#34;); return data[index]; } }; IntArray arr(10); arr[3] = 42; // 使用下标运算符 函数调用运算符：() 1 2 3 4 5 6 7 8 9 10 11 12 class Multiplier { int factor; public: Multiplier(int f) : factor(f) {} int operator()(int x) const { return x * factor; } }; Multiplier times3(3); int result = times3(7); // 返回 21 自增/自减运算符：++, -- 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 class Counter { int count; public: Counter() : count(0) {} // 前置++ Counter\u0026amp; operator++() { ++count; return *this; } // 后置++ (使用int参数区分) Counter operator++(int) { Counter temp = *this; ++(*this); return temp; } }; Counter c; ++c; // 前置 c++; // 后置 继承* 继承(inheritance)机制是面向对象程序设计使代码可以复用的最重要的手段，减少重复代码的编写\n子类会继承父类（public 和 protected）修饰的成员，因此子类可以赋值给父类\n子类的构造函数会调用父类的构造函数\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include\u0026lt;iostream\u0026gt; #include\u0026lt;string\u0026gt; using namespace std; class Person {\t// 父类(基类) public: void Print() { cout \u0026lt;\u0026lt; \u0026#34;name:\u0026#34; \u0026lt;\u0026lt; _name \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;age:\u0026#34; \u0026lt;\u0026lt; _age \u0026lt;\u0026lt; endl; } protected: string _name = \u0026#34;noname\u0026#34;; //姓名 int _age = 20; //年龄 }; class Student : public Person {\t//子类(派生类) protected: int _stuid; //学号 }; class Teacher : public Person {\t//这里继承方式为public protected: int _jobid; //工号 }; int main() { Student s; Teacher t; s.Print(); t.Print(); return 0; } Java支持多层继承，但不支持多重继承；而C++既支持多层继承，也支持多重继承\n从底层角度来看，继承的本质就是复制，private成员在继承同样被复制到子类，但是无法直接使用，可以用指针访问\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 struct Base { public: Base(){ x = 1; y = 2; } private: int x; int y; } class Sub:public Base{ public: int a; int b; } int main() { Sub s1; int* p = (int*)\u0026amp;s1; cout \u0026lt;\u0026lt; *p \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; *(p + 1) \u0026lt;\u0026lt; endl; } 这里了解即可，以后需要用再学，思想应该和Java差不多\n多态* 多态分为两类\n静态的多态：函数重载，在编译时决定 动态的多态：一个父类的引用或指针调用同一个函数，传递不同的对象，会调用不同的函数，即函数重写，如子类重写父类的方法，在运行时决定 多态有两个条件\n必须通过基类的指针或者引用调用虚函数，对象没有多态\n被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写，如：父类的析构函数应定义成虚函数\n虚函数：被virtual修饰的类成员函数（准确的说，只有类的非静态成员函数才能是虚函数，其他函数不能成为虚函数）\n虚函数* 当类中有虚函数时，会在当前对象this指针最前面多一个属性，是一个4字节地址，指向虚函数表（存储了所有虚函数地址），有几个直接父类就有几个虚函数表\n通过对象调用时，virtual函数和普通函数都是直接调用（E8 \u0026hellip;）\n如果用指针调用虚函数，是间接调用（call [在该地址取值] -\u0026gt; FF \u0026hellip;）\n打印虚函数表并调用验证\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 class myA { public: myA() { x = 10; y = 13; } int x; int y; virtual void fun1() { printf(\u0026#34;fun1...\\n\u0026#34;); } virtual void fun2() { printf(\u0026#34;fun2...\\n\u0026#34;); } }; int main(){ myA m; myA* p = \u0026amp;m; p-\u0026gt;fun1(); p-\u0026gt;fun2(); int* pm = (int*)\u0026amp;m; int pv = *pm;\t//虚函数表地址 int af1 = *(int*)pv; int af2 = *((int*)pv + 1); printf(\u0026#34;pm: 0x%X, pv: 0x%X, af1: 0x%X, af2: 0x%X\\n\u0026#34;, pm, pv, af1, af2); typedef void(*pFunc)(void);\t//定义函数指针类型 pFunc pf1 = (pFunc)af1; pFunc pf2 = (pFunc)af2; pf1(); pf2(); return 0; } 练习：\n1.单继承无函数覆盖（重写？）（打印Sub对象的虚函数表）\n2.单继承有重写（打印Sub对象的虚函数表）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 struct Base { public: virtual void fun1() { printf(\u0026#34;Base: fun1...\\n\u0026#34;); } virtual void fun2() { printf(\u0026#34;Base: fun2...\\n\u0026#34;); } virtual void fun3() { printf(\u0026#34;Base: fun3...\\n\u0026#34;); } }; struct Sub :Base { public: virtual void fun1() {\t//父类的fun1、fun2被重写 printf(\u0026#34;Sub: fun1...\\n\u0026#34;); } virtual void fun2() { printf(\u0026#34;Sub: fun2...\\n\u0026#34;); } virtual void fun6() { printf(\u0026#34;Sub: fun6...\\n\u0026#34;); } }; int main() { Sub su; printf(\u0026#34;Sub的虚函数表地址： 0x%X\\n\u0026#34;, *(int*)\u0026amp;su); typedef void(*pFun)(void); pFun pf; for (int i = 0;i \u0026lt; 4;i++) { pf = (pFun)*((int*)(*(int*)\u0026amp;su) + i); pf(); } } 3.多继承无重写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 struct Base1 { public: virtual void fun1() { printf(\u0026#34;Base1: fun1...\\n\u0026#34;); } virtual void fun2() { printf(\u0026#34;Base1: fun2...\\n\u0026#34;); } }; struct Base2 { public: virtual void fun3() { printf(\u0026#34;Base2: fun3...\\n\u0026#34;); } virtual void fun4() { printf(\u0026#34;Base2: fun4...\\n\u0026#34;); } }; struct Sub :Base1, Base2 { public: virtual void fun5() { printf(\u0026#34;Sub: fun5...\\n\u0026#34;); } virtual void fun6() { printf(\u0026#34;Sub: fun6...\\n\u0026#34;); } }; int main() { Sub su; cout \u0026lt;\u0026lt; \u0026#34;SizeofSub:\u0026#34; \u0026lt;\u0026lt; sizeof(su) \u0026lt;\u0026lt; endl; typedef void(*pFun)(void); pFun pf; for (int i = 0;i \u0026lt; 2;i++) {\t//有两个父类则有两个虚函数表 int av = *((int*)\u0026amp;su + i); printf(\u0026#34;Sub的虚函数表[%d]地址： 0x%X\\n\u0026#34;, i, av); for (int j = 0;j \u0026lt; 4;j++) { int tmp = *((int*)av + j); if (tmp == 0) { break; } pf = (pFun)tmp; pf(); } } } 4.多继承有重写\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 struct Base1 { public: virtual void fun1() { printf(\u0026#34;Base1: fun1...\\n\u0026#34;); } virtual void fun2() { printf(\u0026#34;Base1: fun2...\\n\u0026#34;); } }; struct Base2 { public: virtual void fun3() { printf(\u0026#34;Base2: fun3...\\n\u0026#34;); } virtual void fun4() { printf(\u0026#34;Base2: fun4...\\n\u0026#34;); } }; struct Sub :Base1, Base2 { public: virtual void fun1() {\t//父类的fun1、fun3被重写 printf(\u0026#34;Sub: fun1...\\n\u0026#34;); } virtual void fun3() { printf(\u0026#34;Sub: fun3...\\n\u0026#34;); } virtual void fun5() { printf(\u0026#34;Sub: fun5...\\n\u0026#34;); } }; 5.多层继承无重写（类似嵌套单继承，子类重写父类的方法，即覆盖对应虚函数地址）\n6.多层继承有重写\n重载\u0026amp;重写 绑定（Binding）指的是将标识符（如变量名、函数名）与内存中的实际存储位置或具体实现关联起来的过程，绑定本质是建立映射关系，根据发生的时机不同，绑定主要分为两大类：\n一、静态绑定\n定义：在编译期间确定标识符与具体实现的关联\n特点：\n编译时即确定调用关系 高效但缺乏灵活性 基于变量/指针的声明类型 应用场景：\n普通函数调用 非虚成员函数调用 重载函数选择 模板实例化 运算符重载 二、动态绑定\n定义：在运行期间确定标识符与具体实现的关联\n特点：\n运行时动态确定调用关系 通过虚函数机制实现 基于对象的实际类型 C++中，只有virtual函数是动态绑定的，应用：多态、接口实现、设计模式\n绑定是多态的实现基础，即重载和重写\n重载属于编译时多态，如：\n1 2 3 4 5 6 class Calculator { public: // 重载：编译时多态（静态绑定） int add(int a, int b) { return a + b; } // 绑定到add_int double add(double a, double b) { return a + b; } // 绑定到add_double }; 特点：\n相同作用域（同一个类） 函数名相同，参数不同 编译器根据调用参数静态绑定具体函数 重写属于运行时多态，如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Animal { public: virtual void speak() { cout \u0026lt;\u0026lt; \u0026#34;Animal sound\u0026#34; \u0026lt;\u0026lt; endl; } // 虚函数 }; class Cat : public Animal { public: void speak() override { cout \u0026lt;\u0026lt; \u0026#34;Meow\u0026#34; \u0026lt;\u0026lt; endl; } // 重写（动态绑定） }; class Dog : public Animal { public: void speak() override { cout \u0026lt;\u0026lt; \u0026#34;Woof\u0026#34; \u0026lt;\u0026lt; endl; } // 重写（动态绑定） }; 特点：\n不同作用域（基类与派生类） 函数签名完全相同 通过虚函数表动态绑定具体实现 模板 C++模板是实现编译时多态的核心机制，它允许开发者编写与类型无关的通用代码，编译器在编译期间根据具体类型生成特化版本\n1.函数模板\n1 2 3 4 5 6 7 8 // 通用比较函数 template \u0026lt;typename T\u0026gt; T max(T a, T b) { return (a \u0026gt; b) ? a : b; } // 编译器自动生成特化版本 int m1 = max(10, 20); // T = int double m2 = max(3.14, 2.71); // T = double 2.类模板\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template \u0026lt;typename T\u0026gt; class Stack { private: std::vector\u0026lt;T\u0026gt; elements; public: void push(const T\u0026amp; element) { elements.push_back(element); } T pop() { T top = elements.back(); elements.pop_back(); return top; } }; // 使用 Stack\u0026lt;int\u0026gt; intStack; Stack\u0026lt;std::string\u0026gt; strStack; 例1：模板实现通用 Swap 函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;utility\u0026gt; // 用于std::move #include \u0026lt;iostream\u0026gt; // 在全局作用域定义类 class Point { int x, y; public: Point(int x, int y) : x(x), y(y) {} // 声明友元函数 friend std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const Point\u0026amp; p); }; // 在全局作用域定义友元函数 std::ostream\u0026amp; operator\u0026lt;\u0026lt;(std::ostream\u0026amp; os, const Point\u0026amp; p) { return os \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; p.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; } // 基础模板：使用移动语义实现通用交换 template \u0026lt;typename T\u0026gt; void my_swap(T\u0026amp; a, T\u0026amp; b) noexcept { T temp = std::move(a); a = std::move(b); b = std::move(temp); } // 特化版本：针对数组的高效交换 template \u0026lt;typename T, size_t N\u0026gt; void my_swap(T(\u0026amp;a)[N], T(\u0026amp;b)[N]) noexcept { for (size_t i = 0; i \u0026lt; N; ++i) { my_swap(a[i], b[i]); } } // 测试用例 int main() { // 测试1：基本类型 int x = 10, y = 20; std::cout \u0026lt;\u0026lt; \u0026#34;交换前: x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; std::endl; my_swap(x, y); std::cout \u0026lt;\u0026lt; \u0026#34;交换后: x = \u0026#34; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026#34;, y = \u0026#34; \u0026lt;\u0026lt; y \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; std::endl; // 测试2：字符串 std::string s1 = \u0026#34;Hello\u0026#34;, s2 = \u0026#34;World\u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;交换前: s1 = \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; \u0026#34;, s2 = \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; std::endl; my_swap(s1, s2); std::cout \u0026lt;\u0026lt; \u0026#34;交换后: s1 = \u0026#34; \u0026lt;\u0026lt; s1 \u0026lt;\u0026lt; \u0026#34;, s2 = \u0026#34; \u0026lt;\u0026lt; s2 \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; std::endl; Point p1(1, 2), p2(3, 4); std::cout \u0026lt;\u0026lt; \u0026#34;交换前: p1 = \u0026#34; \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; \u0026#34;, p2 = \u0026#34; \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; std::endl; my_swap(p1, p2); std::cout \u0026lt;\u0026lt; \u0026#34;交换后: p1 = \u0026#34; \u0026lt;\u0026lt; p1 \u0026lt;\u0026lt; \u0026#34;, p2 = \u0026#34; \u0026lt;\u0026lt; p2 \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; std::endl; // 测试4：容器 std::vector\u0026lt;int\u0026gt; v1 = { 1, 2, 3 }, v2 = { 4, 5, 6 }; std::cout \u0026lt;\u0026lt; \u0026#34;交换前: v1 = [\u0026#34;; for (int n : v1) std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;], v2 = [\u0026#34;; for (int n : v2) std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; std::endl; my_swap(v1, v2); std::cout \u0026lt;\u0026lt; \u0026#34;交换后: v1 = [\u0026#34;; for (int n : v1) std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;], v2 = [\u0026#34;; for (int n : v2) std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; std::endl \u0026lt;\u0026lt; std::endl; // 测试5：数组 int arr1[3] = { 10, 20, 30 }; int arr2[3] = { 40, 50, 60 }; std::cout \u0026lt;\u0026lt; \u0026#34;交换前: arr1 = [\u0026#34;; for (int n : arr1) std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;], arr2 = [\u0026#34;; for (int n : arr2) std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; std::endl; my_swap(arr1, arr2); std::cout \u0026lt;\u0026lt; \u0026#34;交换后: arr1 = [\u0026#34;; for (int n : arr1) std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;], arr2 = [\u0026#34;; for (int n : arr2) std::cout \u0026lt;\u0026lt; n \u0026lt;\u0026lt; \u0026#34; \u0026#34;; std::cout \u0026lt;\u0026lt; \u0026#34;]\u0026#34; \u0026lt;\u0026lt; std::endl; return 0; } 例2：模板实现通用二分查找算法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; #include \u0026lt;functional\u0026gt; // 用于std::function #include \u0026lt;cctype\u0026gt; // 用于字符串大小写不敏感比较 #include \u0026lt;algorithm\u0026gt; // 版本1：使用迭代器的通用二分查找 template \u0026lt;typename Iterator, typename T\u0026gt; Iterator binary_search_iterator(Iterator first, Iterator last, const T\u0026amp; value) { auto low = first; auto high = last; // 指向最后一个元素 while (low \u0026lt; high) { auto mid = low + std::distance(low, high) / 2; if (*mid == value) { return mid; // 找到元素，返回迭代器 } else if (*mid \u0026lt; value) { low = mid + 1; } else { high = mid; } } return last; // 未找到，返回结束迭代器 } // 版本2：支持自定义比较函数的二分查找 template \u0026lt;typename Iterator, typename T, typename Compare\u0026gt; Iterator binary_search_iterator(Iterator first, Iterator last, const T\u0026amp; value, Compare comp) { auto low = first; auto high = last; while (low \u0026lt; high) { auto mid = low + std::distance(low, high) / 2; if (comp(*mid, value)) { low = mid + 1; } else if (comp(value, *mid)) { high = mid; } else { return mid; // 找到元素 } } return last; // 未找到 } // 版本3：直接处理容器类型的便捷接口 template \u0026lt;typename Container, typename T\u0026gt; auto binary_search(const Container\u0026amp; container, const T\u0026amp; value) -\u0026gt; decltype(container.begin()) { return binary_search_iterator(container.begin(), container.end(), value); } // 版本4：带自定义比较函数的容器接口 template \u0026lt;typename Container, typename T, typename Compare\u0026gt; auto binary_search(const Container\u0026amp; container, const T\u0026amp; value, Compare comp) -\u0026gt; decltype(container.begin()) { return binary_search_iterator(container.begin(), container.end(), value, comp); } // 测试用例：自定义结构体 struct Person { int id; std::string name; double salary; // 按ID比较 bool operator\u0026lt;(const Person\u0026amp; other) const { return id \u0026lt; other.id; } bool operator==(const Person\u0026amp; other) const { return id == other.id; } }; // 自定义比较函数：大小写不敏感的字符串比较 bool case_insensitive_compare(const std::string\u0026amp; a, const std::string\u0026amp; b) { if (a.size() != b.size()) return false; for (size_t i = 0; i \u0026lt; a.size(); ++i) { if (std::tolower(a[i]) != std::tolower(b[i])) { return false; } } return true; } // 自定义比较函数对象：按薪水比较 struct SalaryComparator { bool operator()(const Person\u0026amp; a, const Person\u0026amp; b) const { return a.salary \u0026lt; b.salary; } }; int main() { // 测试1：内置类型数组 int int_array[] = { 1, 3, 5, 7, 9, 11, 13, 15 }; int size = sizeof(int_array) / sizeof(int); auto int_result = binary_search_iterator(int_array, int_array + size, 7); if (int_result != int_array + size) { std::cout \u0026lt;\u0026lt; \u0026#34;在数组中找到 7: \u0026#34; \u0026lt;\u0026lt; *int_result \u0026lt;\u0026lt; std::endl; } else { std::cout \u0026lt;\u0026lt; \u0026#34;在数组中未找到 7\u0026#34; \u0026lt;\u0026lt; std::endl; } // 测试2：标准库容器 std::vector\u0026lt;double\u0026gt; double_vec = { 1.1, 2.2, 3.3, 4.4, 5.5, 6.6 }; auto double_result = binary_search(double_vec, 4.4); if (double_result != double_vec.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;在vector中找到 4.4: \u0026#34; \u0026lt;\u0026lt; *double_result \u0026lt;\u0026lt; std::endl; } // 测试3：自定义结构体 std::vector\u0026lt;Person\u0026gt; people = { {101, \u0026#34;Alice\u0026#34;, 50000.0}, {102, \u0026#34;Bob\u0026#34;, 60000.0}, {103, \u0026#34;Charlie\u0026#34;, 55000.0}, {104, \u0026#34;David\u0026#34;, 70000.0} }; // 按ID排序和搜索 std::sort(people.begin(), people.end()); Person search_person{ 103, \u0026#34;Charlie\u0026#34;, 0.0 }; auto person_result = binary_search(people, search_person); if (person_result != people.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;找到ID为103的人: \u0026#34; \u0026lt;\u0026lt; person_result-\u0026gt;name \u0026lt;\u0026lt; std::endl; } // 测试4：自定义比较函数（按薪水搜索） SalaryComparator salary_comp; std::sort(people.begin(), people.end(), salary_comp); Person salary_search{ 0, \u0026#34;\u0026#34;, 55000.0 }; auto salary_result = binary_search(people, salary_search, salary_comp); if (salary_result != people.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;找到薪水为55000的人: \u0026#34; \u0026lt;\u0026lt; salary_result-\u0026gt;name \u0026lt;\u0026lt; std::endl; } // 测试5：大小写不敏感的字符串搜索 std::vector\u0026lt;std::string\u0026gt; words = { \u0026#34;Apple\u0026#34;, \u0026#34;Banana\u0026#34;, \u0026#34;Cherry\u0026#34;, \u0026#34;Date\u0026#34;, \u0026#34;Fig\u0026#34; }; std::sort(words.begin(), words.end()); // 使用自定义比较函数 auto string_result = binary_search_iterator( words.begin(), words.end(), \u0026#34;cherry\u0026#34;, // 注意小写 [](const std::string\u0026amp; a, const std::string\u0026amp; b) { for (size_t i = 0; i \u0026lt; std::min(a.size(), b.size()); ++i) { char ca = std::tolower(a[i]); char cb = std::tolower(b[i]); if (ca != cb) return ca \u0026lt; cb; } return a.size() \u0026lt; b.size(); } ); if (string_result != words.end()) { std::cout \u0026lt;\u0026lt; \u0026#34;找到 \u0026#39;cherry\u0026#39; (大小写不敏感): \u0026#34; \u0026lt;\u0026lt; *string_result \u0026lt;\u0026lt; std::endl; } return 0; } 引用 引用不是新定义一个变量，而是给已存在变量取了一个别名，编译器不会为引用变量开辟内存空间，它和它引用的变量共用同一块内存空间\n引用是变量的别名：引用不是新变量，而是已有变量的另一个名称 引用必须初始化：声明时必须绑定到一个已存在的变量 引用不可重新绑定：一旦初始化后，不能改变其引用的对象 不占用额外内存（通常）：引用本身不占用存储空间（编译器实现细节） 引用在函数中的应用 避免拷贝 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 #include \u0026lt;iostream\u0026gt; #include \u0026lt;string\u0026gt; using namespace std; // 按值传递（产生拷贝） void print_by_value(string str) { cout \u0026lt;\u0026lt; \u0026#34;按值传递: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; } // 按引用传递（无拷贝） void print_by_reference(const string\u0026amp; str) { cout \u0026lt;\u0026lt; \u0026#34;按引用传递: \u0026#34; \u0026lt;\u0026lt; str \u0026lt;\u0026lt; endl; } int main() { string long_str = \u0026#34;这是一个很长的字符串，用于演示拷贝开销...\u0026#34;; print_by_value(long_str); // 产生字符串拷贝 print_by_reference(long_str); // 无拷贝 return 0; } 修改函数参数（替代指针） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; // 使用引用修改参数 void increment(int\u0026amp; num) { num++; } // 使用指针的等效版本 void increment_ptr(int* num) { (*num)++; } int main() { int a = 5; increment(a); // 不需要取地址操作 cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 输出 6 increment_ptr(\u0026amp;a); // 需要显式取地址 cout \u0026lt;\u0026lt; \u0026#34;a = \u0026#34; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; endl; // 输出 7 return 0; } 返回引用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; using namespace std; // 返回数组中最大元素的引用 int\u0026amp; find_max(int arr[], int size) { int max_index = 0; for (int i = 1; i \u0026lt; size; i++) { if (arr[i] \u0026gt; arr[max_index]) { max_index = i; } } return arr[max_index]; } int main() { int numbers[] = {3, 5, 2, 8, 6}; int size = sizeof(numbers) / sizeof(numbers[0]); int\u0026amp; max_ref = find_max(numbers, size); cout \u0026lt;\u0026lt; \u0026#34;最大值: \u0026#34; \u0026lt;\u0026lt; max_ref \u0026lt;\u0026lt; endl; // 输出 8 // 通过引用修改数组元素 max_ref = 100; cout \u0026lt;\u0026lt; \u0026#34;修改后数组: \u0026#34;; for (int i = 0; i \u0026lt; size; i++) { cout \u0026lt;\u0026lt; numbers[i] \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 输出 3 5 2 100 6 } cout \u0026lt;\u0026lt; endl; return 0; } 高级引用用法 const 引用（只读访问） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include \u0026lt;iostream\u0026gt; using namespace std; void print_value(const int\u0026amp; num) { // num = 10; // 错误：不能通过const引用修改 cout \u0026lt;\u0026lt; \u0026#34;值: \u0026#34; \u0026lt;\u0026lt; num \u0026lt;\u0026lt; endl; } int main() { int a = 5; const int\u0026amp; const_ref = a; // const_ref = 10; // 错误：不能通过const引用修改 a = 10; // 但原始变量可以修改 cout \u0026lt;\u0026lt; \u0026#34;const_ref: \u0026#34; \u0026lt;\u0026lt; const_ref \u0026lt;\u0026lt; endl; // 输出 10 // 绑定到临时值 const int\u0026amp; temp_ref = 42; cout \u0026lt;\u0026lt; \u0026#34;临时值引用: \u0026#34; \u0026lt;\u0026lt; temp_ref \u0026lt;\u0026lt; endl; return 0; } 引用与范围 for 循环 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;iostream\u0026gt; #include \u0026lt;vector\u0026gt; using namespace std; int main() { vector\u0026lt;int\u0026gt; numbers = {1, 2, 3, 4, 5}; // 使用引用修改元素 for (int\u0026amp; num : numbers) { num *= 2; // 每个元素加倍 } // 使用const引用只读访问 for (const int\u0026amp; num : numbers) { cout \u0026lt;\u0026lt; num \u0026lt;\u0026lt; \u0026#34; \u0026#34;; // 输出 2 4 6 8 10 } cout \u0026lt;\u0026lt; endl; return 0; } 右值引用（C++11 新特性） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include \u0026lt;iostream\u0026gt; #include \u0026lt;utility\u0026gt; // for std::move using namespace std; void process_value(int\u0026amp; val) { cout \u0026lt;\u0026lt; \u0026#34;左值引用: \u0026#34; \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; } void process_value(int\u0026amp;\u0026amp; val) { cout \u0026lt;\u0026lt; \u0026#34;右值引用: \u0026#34; \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl; } int main() { int a = 10; process_value(a); // 调用左值版本 process_value(20); // 调用右值版本 process_value(move(a)); // 使用 std::move 转为右值 return 0; } 友元 友元是 C++ 中打破封装性的一种特殊机制，它允许特定的外部函数或类访问另一个类的私有（private）和保护（protected）成员\n友元关系的核心特点：\n授权访问：被声明为友元的实体可以访问类的私有和保护成员 单向性：友元关系是单向的（A 是 B 的友元 ≠ B 是 A 的友元） 非传递性：友元关系不传递（A 是 B 的友元，B 是 C 的友元 ≠ A 是 C 的友元） 不继承：友元关系不被派生类继承 声明位置：\n1 2 3 4 5 6 7 8 class MyClass { public: friend void friendFunction(); // 有效 private: friend class FriendClass; // 有效 protected: friend void anotherFriend(); // 有效 }; 友元的三种形式 友元函数（没有this指针） 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include \u0026lt;iostream\u0026gt; using namespace std; class Box { private: double width; public: Box(double w) : width(w) {} // 声明友元函数 friend void printWidth(Box box); }; // 友元函数定义（可以访问私有成员） void printWidth(Box box) { cout \u0026lt;\u0026lt; \u0026#34;Box width: \u0026#34; \u0026lt;\u0026lt; box.width \u0026lt;\u0026lt; endl; } int main() { Box box(10.0); printWidth(box); // 输出: Box width: 10 return 0; } 友元类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include \u0026lt;iostream\u0026gt; using namespace std; class Box { private: double width; public: Box(double w) : width(w) {} // 声明友元类 friend class BoxPrinter; }; class BoxPrinter { public: void print(Box box) { // 可以访问Box的私有成员 cout \u0026lt;\u0026lt; \u0026#34;Box width: \u0026#34; \u0026lt;\u0026lt; box.width \u0026lt;\u0026lt; endl; } }; int main() { Box box(20.0); BoxPrinter printer; printer.print(box); // 输出: Box width: 20 return 0; } 友元成员函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; using namespace std; class Box; // 前向声明 class BoxPrinter { public: void print(Box box); // 成员函数声明 }; class Box { private: double width; public: Box(double w) : width(w) {} // 声明特定成员函数为友元 friend void BoxPrinter::print(Box box); }; // 成员函数定义（需要完整Box定义） void BoxPrinter::print(Box box) { // 可以访问Box的私有成员 cout \u0026lt;\u0026lt; \u0026#34;Box width: \u0026#34; \u0026lt;\u0026lt; box.width \u0026lt;\u0026lt; endl; } int main() { Box box(30.0); BoxPrinter printer; printer.print(box); // 输出: Box width: 30 return 0; } 友元的使用场景 运算符重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include \u0026lt;iostream\u0026gt; using namespace std; class Complex { private: double real; double imag; public: Complex(double r, double i) : real(r), imag(i) {} // 声明友元运算符重载 friend Complex operator+(const Complex\u0026amp; c1, const Complex\u0026amp; c2); void print() { cout \u0026lt;\u0026lt; real \u0026lt;\u0026lt; \u0026#34; + \u0026#34; \u0026lt;\u0026lt; imag \u0026lt;\u0026lt; \u0026#34;i\u0026#34; \u0026lt;\u0026lt; endl; } }; // 实现友元运算符 Complex operator+(const Complex\u0026amp; c1, const Complex\u0026amp; c2) { return Complex(c1.real + c2.real, c1.imag + c2.imag); } int main() { Complex a(2.5, 3.1); Complex b(1.7, 2.3); Complex c = a + b; c.print(); // 输出: 4.2 + 5.4i return 0; } 流运算符重载 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include \u0026lt;iostream\u0026gt; using namespace std; class Point { private: int x; int y; public: Point(int x, int y) : x(x), y(y) {} // 声明友元流运算符 friend ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Point\u0026amp; p); }; // 实现输出运算符 ostream\u0026amp; operator\u0026lt;\u0026lt;(ostream\u0026amp; os, const Point\u0026amp; p) { os \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; p.x \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; p.y \u0026lt;\u0026lt; \u0026#34;)\u0026#34;; return os; } int main() { Point p(3, 4); cout \u0026lt;\u0026lt; \u0026#34;Point: \u0026#34; \u0026lt;\u0026lt; p \u0026lt;\u0026lt; endl; // 输出: Point: (3, 4) return 0; } 紧密协作的类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026lt;iostream\u0026gt; using namespace std; class Engine; // 前向声明 class Car { private: string model; friend class Mechanic; // 授权Mechanic访问 }; class Engine { private: string type; friend class Mechanic; // 授权Mechanic访问 }; class Mechanic { public: void repair(Car\u0026amp; car, Engine\u0026amp; engine) { cout \u0026lt;\u0026lt; \u0026#34;Repairing car model: \u0026#34; \u0026lt;\u0026lt; car.model \u0026lt;\u0026lt; endl; cout \u0026lt;\u0026lt; \u0026#34;Fixing engine type: \u0026#34; \u0026lt;\u0026lt; engine.type \u0026lt;\u0026lt; endl; // 可以访问Car和Engine的私有成员 } }; int main() { Car myCar; Engine myEngine; Mechanic bob; bob.repair(myCar, myEngine); return 0; } new-delete new 和 delete 是 C++ 中用于动态内存管理的核心运算符，它们提供了在程序运行时分配和释放内存的能力。与 C 语言中的 malloc 和 free 不同，new 和 delete 是类型安全的，并且会调用对象的构造函数和析构函数\nnew 运算符 new是在堆中创建对象\n基本用法 1 2 3 4 5 6 // 分配单个对象 int* pInt = new int; // 未初始化 int* pInt2 = new int(42); // 初始化为42 // 分配对象数组 int* arr = new int[10]; // 10个整数的数组 内存分配过程 new 的变体 (1) 定位 new（Placement new）\n1 2 3 4 5 6 #include \u0026lt;new\u0026gt; // 必须包含头文件 char buffer[1024]; // 预分配内存 // 在指定内存位置构造对象 int* p = new (buffer) int(100); (2) nothrow new\n1 2 3 4 5 // 分配失败时不抛出异常，返回 nullptr int* p = new (std::nothrow) int[1000000000]; if (!p) { // 处理内存分配失败 } delete 运算符 基本用法 1 2 3 4 5 6 7 // 释放单个对象 delete pInt; // 释放内存 pInt = nullptr; // 避免悬空指针 // 释放对象数组 delete[] arr; // 注意使用 [] arr = nullptr; 内存释放过程 参考\nc++类和对象（上）this指针\n【C++】类和对象（中）—— 构造函数 + 析构函数\n【C++】多态\n","date":"2025-07-23T00:00:00Z","image":"https://567liuhuaqing.github.io/p/c-/%E7%B2%BE%E7%81%B5_hu_1edad381159032c2.jpg","permalink":"https://567liuhuaqing.github.io/p/c-/","title":"C++"},{"content":"在C++开发中，库（Library）是代码复用的重要方式，库的存在形式本质上来说库是一种可执行代码的二进制，分为静态库（.lib、.a）和动态库（.dll、.so）\n静态链接库 静态库是一种在编译时将代码直接嵌入到可执行文件中的库文件，它具有独立性、性能优势和版本控制等特点，适用于许多不同类型的项目和开发环境。如果你想要别人使用你的代码，但又不想将源代码公开的时候，也可以使用\n优：静态写入封装，代码重用\n缺：直接编译到exe（如若修改.lib，需重新编译exe）\n创建静态链接库 这里以Visual Studio 2022为例\n方法一： 首先创建新项目模板为**“静态库”** 也可以在项目属性页修改配置类型\n若要自定义头文件，C/C++ → 预编译头 → 设置为\u0026quot;不使用预编译头\u0026quot;\n在pch.h中添加函数或类预定义\n1 2 3 4 5 6 7 #pragma once void PPTe(); namespace test { void castue(); } 在pch.cpp中写出完整的类与方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026#34;pch.h\u0026#34; using namespace std; void PPTe(){ cout \u0026lt;\u0026lt; \u0026#34;Hello World \u0026#34; \u0026lt;\u0026lt; endl; } namespace test { void castue() { cout \u0026lt;\u0026lt; \u0026#34;Ualeo Teui\u0026#34; \u0026lt;\u0026lt; endl; } } 选择“生成” -\u0026gt; “生成解决方案”（Ctrl+Shift+B）\n在“x64” -\u0026gt; “Debug”中生成lib文件如下\n然后创建一个新项目**“控制台应用”** 将刚刚生成的lib文件和头文件打包复制到新项目文件夹\n在源文件中预定义头文件，并且在代码中指定需要链接的库文件，添加代码为\n1 2 #include \u0026#34;pch.h\u0026#34; #pragma comment(lib, \u0026#34;TestLib.lib\u0026#34;) 这样就成功导入静态链接库啦，可以使用静态库中的类与方法\n方法二： 刚刚的指定需要链接的库文件代码不添加\n将头文件和库文件打包在同一个文件夹，将该文件夹路径添加到项目属性 → VC++目录 → 包含目录和库目录，注意前面要加; （如果是方法一中直接复制文件到新项目就跳过此步）\n项目属性中设置：打开项目属性 → 链接器 → 输入，在\u0026quot;附加依赖项\u0026quot;中添加 TestLib.lib\n或者打开项目属性 → 链接器 → 命令行，在“其他选项”中添加 TestLib.lib\n点击“应用” → “确定”，和上述功能相同\n动态链接库 动态库指的是在程序运行过程中动态加载库的方式使用的库，也就是动态库的链接是发生在程序运行时期的，它和可执行文件是分开的，只是可执行文件在运行的某个时期调用了它。\n优：程序自身的体积不会因为动态函数库变大\n缺：就是程序运行过程中使用到了这些函数库内的功能时，若系统特定的位置没有对应的动态库，就会造成程序崩溃或者各种奇怪的问题\n创建动态链接库 方法一：隐式调用 创建新项目模板为**“动态链接库”**\n或配置属性 → 常规 → 配置类型：动态库(.dll)\n函数声明与生成静态库不一样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #pragma once // DLL导出宏 #ifdef STRINGDYNAMICLIB_EXPORTS\t//若使用该语句，C/C++ → 预处理器 → 预处理器定义：添加STRINGDYNAMICLIB_EXPORTS #define STRING_API __declspec(dllexport)\t//导出声明(__declspec(dllexport))告诉编译器哪些函数应该对外可见，没有导出的函数无法从外部调用 #else #define STRING_API __declspec(dllimport) #endif namespace StringDynamic { STRING_API void reverse(char* str, int length);\t// 反转字符串 STRING_API int countChar(const char* str, char c);\t// 统计字符出现次数 STRING_API char* concatenate(const char* str1, const char* str2);\t// 连接两个字符串 } .cpp代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026#34;pch.h\u0026#34; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; namespace StringDynamic { STRING_API void reverse(char* str, int length) { int start = 0; int end = length - 1; while (start \u0026lt; end) { std::swap(str[start], str[end]); start++; end--; } } STRING_API int countChar(const char* str, char c) { int count = 0; while (*str) { if (*str == c) count++; str++; } return count; } STRING_API char* concatenate(const char* str1, const char* str2) { size_t len1 = strlen(str1); size_t len2 = strlen(str2); char* result = (char*)malloc(len1 + len2 + 1); strcpy(result, str1); strcat(result, str2); return result; } } 选择“生成” -\u0026gt; “生成解决方案”（Ctrl+Shift+B），会生成dll文件和lib\n同样创建一个新项目，将dll和lib打包复制到新项目文件夹中\n1 2 3 #pragma comment(lib, \u0026#34;TestDll.lib\u0026#34;) extern \u0026#34;C\u0026#34; _declspec(dllimport) int __stdcall mySub(int x, int y);\t//导入函数时要跟声明类型的一样 方法二：显示调用 dll文件为方法一中生成的，将dll与exe放于同一目录\n1 2 3 4 5 6 7 8 9 10 11 #include \u0026lt;windows.h\u0026gt; //使用LoadLibrary函数必须包含此头文件 #include \u0026lt;iostream\u0026gt; using namespace std; typedef int(__stdcall* lpSub)(int, int); //定义函数指针 int main() { lpSub mySub;\t//声明函数指针变量\t//动态加载dll到内存 HINSTANCE hModule = LoadLibrary(L\u0026#34;TestDll.dll\u0026#34;); //L -\u0026gt; 宽字符版本 -\u0026gt; 现代Windows兼容 mySub = (lpSub)GetProcAddress(hModule, \u0026#34;mySub\u0026#34;); //获取函数地址 cout \u0026lt;\u0026lt; \u0026#34;2-1=\u0026#34; \u0026lt;\u0026lt; mySub(2, 1) \u0026lt;\u0026lt; endl; //若是32位程序，__stdcall类型则为_mySub@8 FreeLibrary(hModule);\t//释放dll } 静态库与动态库对比 使用.def导出库 同样使用动态链接库项目，def导出可以隐藏函数名\npch.h\n1 int myMul(int x, int y); pch.cpp\n1 2 3 int myMul(int x, int y) { return x * y; } test.def\n1 2 3 EXPORTS Mul @13\tNONAME\t//13为该函数序号 NONAME表示没有名字，即隐藏函数名 配置属性 → 链接器 → 输入中模块定义文件添加刚刚的test.def\n选择“生成” -\u0026gt; “生成解决方案”（Ctrl+Shift+B），显示调用代码为\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;windows.h\u0026gt; //使用LoadLibrary函数必须包含此头文件 #include \u0026lt;iostream\u0026gt; using namespace std; typedef int(*lpMul)(int, int); //定义函数指针 int main() { lpMul myMul; //声明函数指针变量 //动态加载dll到内存 HINSTANCE hModule = LoadLibrary(L\u0026#34;TestDll2.dll\u0026#34;); //L -\u0026gt; 宽字符版本 -\u0026gt; 现代Windows兼容 myMul = (lpMul)GetProcAddress(hModule, MAKEINTRESOURCEA(13));\t//通过序号获取函数地址 cout \u0026lt;\u0026lt; \u0026#34;2*1=\u0026#34; \u0026lt;\u0026lt; myMul(2, 1) \u0026lt;\u0026lt; endl; } 通过序号调用可隐藏函数名~\n参考\nVisual Studio 2022静态库与动态库创建及使用完全指南\n","date":"2025-07-15T00:00:00Z","image":"https://567liuhuaqing.github.io/p/%E9%9D%99%E6%80%81/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/%E7%93%B7%E5%BF%83%E5%82%80%E5%84%A1_hu_db2048cbb754b00d.jpg","permalink":"https://567liuhuaqing.github.io/p/%E9%9D%99%E6%80%81/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5%E5%BA%93/","title":"静态/动态链接库"},{"content":"PE结构概述 程序入口地址OEP\nPE格式是 Windows下最常用的可执行文件格式\nPE分节 节省硬盘空间 节省内存空间 PEloader-\u0026gt;PE加载 根据SizeOfImage的大小，开辟一块缓冲区（ImageBuffer） 根据SizeOfHeader的大小，将头信息从FileBuffer拷贝到ImageBuffer 根据节表中的信息循环将FileBuffer中的节拷贝到ImageBuffer中 RVA转化成FOA VA：英文全称是Virual Address，简称VA，中文意思是虚拟地址。指的是文件被载入虚拟空间后的地址。\nImageBase：中文意思是基址，指的是程序在虚拟空间中被装载的位置。\nRVA：英文全称是Relative Virual Address，简称RVA，中文意思是相对虚拟地址。可以理解为文件被装载到虚拟空间(拉伸)后先对于基址的偏移地址。计算方式：RVA = VA(虚拟地址) - ImageBase(基址)。它的对齐方式一般是以1000h为单位在虚拟空间中对齐的(传说中的4K对齐)，具体对齐需要参照IMAGE_OPTIONAL_HEADER32中的SectionAlignment成员。\nFOA：英文全称是File Offset Address，简称FOA，中文意思是文件偏移地址。可以理解为文件在磁盘上存放时相对于文件开头的偏移地址。它的对齐方式一般是以200h为单位在硬盘中对齐的(512对齐)，具体对齐需要参照IMAGE_OPTIONAL_HEADER32中的FileAlignment成员。\n全局变量：如果全局变量没有初始化值，那么这个全局变量在PE文件中是没有保存它的位置的，如果有初始化那么就有它位置保存初始值。定位到全局变量的位置后即可修改。\nFOA(文件偏移，基于PE文件开始的地址0)和RVA(虚拟地址偏移，基于ImageBase)：\n当SectionAlignment（内存中节区对齐大）和FileAlignment（文件中节区对齐大）相同时，这2个偏移相同，现在的大部分程序都相同.\n如果不相同时：要判断是否在PE头中，如果在PE头这个节区那么他们还是相同，如果不在PE头节区，RVA先算出当前虚拟地址相对与当前节区的开始地址的偏移，然后在文件中也找到这个节区在PE文件中的偏移位置加上相同的偏移即可。\n就算SectionAlignment（内存中节区对齐大）和FileAlignment（文件中节区对齐大）相同时，每个节区加载地址也可能不同这时还是要自己转换RVA和FOA\n给出代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 DWORD RvaToFoa(IN LPVOID pFileBuffer, IN DWORD dwRva) { if (pFileBuffer == NULL) { return 0; } PIMAGE_DOS_HEADER pDos = NULL; PIMAGE_NT_HEADERS pNT = NULL; PIMAGE_FILE_HEADER pPE = NULL; PIMAGE_SECTION_HEADER pSec = NULL; pDos = (PIMAGE_DOS_HEADER)pFileBuffer; if (pDos-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) { return 0; } pNT = (PIMAGE_NT_HEADERS)((BYTE*)pFileBuffer + pDos-\u0026gt;e_lfanew); if (pNT-\u0026gt;Signature != IMAGE_NT_SIGNATURE) { return 0; } if (dwRva \u0026lt; pNT-\u0026gt;OptionalHeader.SizeOfHeaders) { return dwRva; } pPE = \u0026amp;pNT-\u0026gt;FileHeader; if (pNT-\u0026gt;FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) { PIMAGE_OPTIONAL_HEADER64 pOpt = (PIMAGE_OPTIONAL_HEADER64)\u0026amp;pNT-\u0026gt;OptionalHeader; pSec = (PIMAGE_SECTION_HEADER)((BYTE*)pOpt + pPE-\u0026gt;SizeOfOptionalHeader); } else { PIMAGE_OPTIONAL_HEADER32 pOpt = (PIMAGE_OPTIONAL_HEADER32)\u0026amp;pNT-\u0026gt;OptionalHeader; pSec = (PIMAGE_SECTION_HEADER)((BYTE*)pOpt + pPE-\u0026gt;SizeOfOptionalHeader); } WORD numSec = pPE-\u0026gt;NumberOfSections; for (WORD i = 0; i \u0026lt; numSec; i++) { DWORD dwVA = pSec-\u0026gt;VirtualAddress;\t//其中dwVA也是该节的RVA DWORD dwVS = pSec-\u0026gt;Misc.VirtualSize; if (dwRva \u0026gt;= dwVA \u0026amp;\u0026amp; dwRva \u0026lt; (dwVA + dwVS)) { // 公式：FOA = RVA - 节区虚拟地址 + 节区文件偏移 DWORD dwFoa = (dwRva - dwVA) + pSec-\u0026gt;PointerToRawData; return dwFoa; } pSec++; } return 0; } 作业见PE加载与回收+RVA转换成FOA.cpp\nPE头字段说明 DOS头 PE文件开始的地方\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 1\tDOS头\t//滴水\t//我自己 typedef struct _IMAGE_DOS_HEADER { WORD e_magic; *\t//Magic number(MZ);\t//5A4D WORD e_cblp;\t//Bytes on last page of file\t//0090 WORD e_cp;\t//Pages in file\t//0003 WORD e_crlc;\t//Relocations\t//0000 WORD e_cparhdr;\t//Size of header in paragraphs\t//0004 WORD e_minalloc;\t//Minimum extra paragraphs needed\t//0000 WORD e_maxalloc;\t//Maximum extra paragraphs needed\t//FFFF WORD e_ss;\t//Initial (relative) SS value\t//0000 WORD e_sp;\t//Initial SP value\t//00B8 WORD e_csum;\t//Checksum\t//0000 WORD e_ip;\t//Initial IP value\t//0000 WORD e_cs;\t//Initial (relative) CS value\t//0000 WORD e_lfarlc;\t//File address of relocation table\t//0040 WORD e_ovno;\t//Overlay number\t//0000 WORD e_res[4];\t//Reserved words\t//0000 0000 0000 0000 WORD e_oemid;\t//OEM identifier (for e_oeminfo)\t//0000 WORD e_oeminfo;\t//OEM information; e_oemid specific\t//0000 WORD e_res2[10];\t//Reserved words\t//0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 DWORD e_lfanew; *\t//File address of new exe header //0000 00E8\t-\u0026gt;\t//0000 0108 } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; NT头/PE头 NT头 = PE标志+ 标准PE头 + 可选PE头\nDOS头字段e_lfanew为NT头开始的地方\n1 2 3 4 5 typedef struct _IMAGE_NT_HEADERS { DWORD Signature; //NT头标志 即\u0026#39;PE..\u0026#39; 00004550 IMAGE_FILE_HEADER FileHeader; //标准PE头 IMAGE_OPTIONAL_HEADER32 OptionalHeader; //扩展PE头 } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 标准PE头/文件头 1 2 3 4 5 6 7 8 9 10 2\t标准PE头 typedef struct _IMAGE_FILE_HEADER { WORD Machine; * //程序运行的CPU型号 x86CPU:0x14C x64CPU:0x8864 WORD NumberOfSections; * //PE中节的数量 DWORD TimeDateStamp; * //时间戳：文件创建的日期和时间 DWORD PointerToSymbolTable; //执行符号表，即编译好的程序生成的pdb文件，用来方便调试的 DWORD NumberOfSymbols; //符号表中的符号数量 WORD SizeOfOptionalHeader; * //可选PE头的大小 x86（32位）:224字节 x64（64位）:240字节 WORD Characteristics; * //文件属性，每个位有不同的含义 x86:0x3 x64:0x22 } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; 可选PE头/扩展头 标准PE头字段SizeOfOptionalHeader为可选PE头大小（32位：E0h字节 / 64位：F0h字节）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 3\t可选PE头 typedef struct _IMAGE_OPTIONAL_HEADER { WORD Magic; * //魔数 x86:0x10B x64:0x20B BYTE MajorLinkerVersion; //链接器的版本 BYTE MinorLinkerVersion; //连接器的版本 DWORD SizeOfCode; * //所有代码区段的大小总和，必须是FileAlignment的整数倍 DWORD SizeOfInitializedData; * //已经初始化数据区段大小总和，必须是FileAlignment的整数倍 DWORD SizeOfUninitializedData; * //未初始化数据区段大小总和，必须是FileAlignment的整数倍 DWORD AddressOfEntryPoint; ** //程序入口OEP+ImageBase DWORD BaseOfCode; * //代码段的起始RVA DWORD BaseOfData; * //数据段的起始RVA（32+PE删除了） DWORD ImageBase; ** //程序建议的加载地址（内存镜像基地址） x64 ULONGLONG DWORD SectionAlignment; ** //内存中的对齐粒度 x86 0x1000 x64 0x2000 DWORD FileAlignment; ** //文件中的对齐粒度 0x200 WORD MajorOperatingSystemVersion; //操作系统版本号 WORD MinorOperatingSystemVersi on; WORD MajorImageVersion; //PE的镜像备案本号 WORD MinorImageVersion; WORD MajorSubsystemVersion; //子系统的版本号。 WORD MinorSubsystemVersion; DWORD Win32VersionValue; //Win32版本（未使用） DWORD SizeOfImage; ** //内存中整个PE镜像的尺寸，必须是SectionAlignment的整数倍 DWORD SizeOfHeaders; ** //所有头+节表按照文件对齐后的大小 DWORD CheckSum; * //校验和 WORD Subsystem; //子系统，其决定了程序入口点main函数的不同，常见的子系统有窗口，控制台等等 WORD DllCharacteristics; //DLL动态链接库特性 DWORD SizeOfStackReserve; * //初始化时的栈大小 DWORD SizeOfStackCommit; * //初始化时实际上提交的栈大小 DWORD SizeOfHeapReserve; * //初始化时保留的堆大小 DWORD SizeOfHeapCommit; * //初始化时实际上提交的堆大小 DWORD LoaderFlags; //加载标记 DWORD NumberOfRvaAndSizes; * //数据目录结构的数量 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; //数据目录表数组 } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; 最重要属性\n1 2 3 4 5 6 7 8 DWORD AddressOfEntryPoint; ** //程序入口OEP+ImageBase DWORD ImageBase; ** //程序建议的加载地址（内存镜像基地址） DWORD SectionAlignment; ** //内存中的对齐粒度 x86 0x1000 x64 0x2000 DWORD FileAlignment; ** //文件中的对齐粒度 0x200 DWORD SizeOfImage; ** //内存中整个PE文件的映像（镜像）的尺寸，必须是SectionAlignment的整数倍 DWORD SizeOfHeaders; ** //所有头+节表按照文件对齐后的大小 DWORD NumberOfRvaAndSizes; * //数据目录结构的数量 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; //数据目录表数组（16*8字节） 节表 可选PE头结束后紧跟着的地方为节表，标准PE表中字段NumberOfSections为节表个数，一个节表大小为40d字节\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #define IMAGE_SIZEOF_SHORT_NAME 8 //宏定义 typedef struct _IMAGE_SECTION_HEADER{ BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; *\t//每一个节都可以取一个名字，最大长度为8字节 union{\t//联合体（大小为最大属性的大小） DWORD PhysicalAddress; DWORD VirtualSize; } Misc; *\t//是该节在没有对齐前的真实尺寸（若被修改则不准确） DWORD VirtualAddress; *\t//节在内存中的偏移地址（相对偏移） DWORD SizeOfRawData; *\t//节在文件中对齐后的尺寸 DWORD PointerToRawData; *\t//节在文件中的偏移 DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; *\t//节的属性 } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 打印所有头和节表代码详见PE头解析.cpp，运行如下\n空白区添加代码 代码节空白区添加代码 1.MessageBox函数说明 MessageBox()函数：功能是弹出一个标准的Windows对话框；它不是C函数库的标准函数，而是一个API，我们可以用C语言调用API函数。可以理解成我们在C中使用MessageBox函数就表示调用系统提供的API函数–MessageBoxA。包含在头文件windows.h；如果一个程序中包含user32.dll，则此程序就有MessageBoxAAPI函数\n2.函数原型\n1 int MessageBox( HWND hWnd,LPCTSTR lpText, LPCTSTR lpCaption = NULL, UINT nType = MB_OK ); 获取MessageBox地址，构造ShellCode代码 E8 E9计算公式，x=MessageBox地址-下一条指令在内存中的地址 在代码区手动添加代码 修改OEP，指向ShellCode 任意节空白区添加代码 新增节添加代码 SizeOfHeader - (DOS + 垃圾数据 + PE标记 + 标准PE头 + 可选PE头 + 已存在的节表) \u0026gt;= 2个节表的大小 需要修改的数据 1）添加一个新的节\n2）在新增节后面，填充一个节大小的000\n3）修改PE头中节的数量NumberOfSections\n4）修改ImageBase的大小\n5）在原有数据的最后，新增一个节的数据为内存对齐的整数倍\n6）修正新增节表的属性\n扩大节-合并节 扩大节\n拉伸到内存\n分配一块新的空间：SizeOfImage + Ex\n将最后一个节的SizeOfRawData和VirtualSize改成N\n其中 N = MAX（SizeOfRawData，VirtualSize）内存对齐 + Ex\n修改SizeOfImage\n合并节\n拉伸到内存\n将第一个节的内存大小、文件大小改成一样\nMax = SizeOfRawData\u0026gt;VirtualSize?SizeOfRawData:VirtualSize\nSizeOfRawData = VirtualSize = 最后一个节的VirtualAddress + Max - SizeOfHeaders内存对齐的大小\n将第一个节的属性改为包含所有节的属性\n修改节的数量为1\n！！！ 这里代码还没贴\n数据目录表 可选PE头最后一个属性就是DataDirectory[16]结构体数组，该结构体中VirtualAddress属性是在内存中的偏移RVA，若要在FileBuffer中定位，则需将RVA转换成FOA\n1 2 3 4 5 #define IMAGE_NUMBEROF_DIRECTORY_ENTRIES 16 typedef struct _IMAGE_DATA_DIRECTORY { DWORD VirtualAddress;\t//内存偏移 DWORD Size;\t//大小 } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY; 16个数据目录的大小一样，都是8字节\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #define IMAGE_DIRECTORY_ENTRY_EXPORT 0 // Export Directory 导出表:动态链接库导出的函数会显示在这里 #define IMAGE_DIRECTORY_ENTRY_IMPORT 1 // Import Directory 导入表:写程序时调用的动态链接库会显示在这里 #define IMAGE_DIRECTORY_ENTRY_RESOURCE 2 // Resource Directory 资源表:图片,图标,字符串,嵌入的程序都在这里 #define IMAGE_DIRECTORY_ENTRY_EXCEPTION 3 // Exception Directory 异常目录表:保存文件中异常处理相关的数据 #define IMAGE_DIRECTORY_ENTRY_SECURITY 4 // Security Directory 安全目录:存放数字签名和安全证书之类的东西 #define IMAGE_DIRECTORY_ENTRY_BASERELOC 5 // Base Relocation Table 基础重定位表:保存需要执行重定位的代码偏移 #define IMAGE_DIRECTORY_ENTRY_DEBUG 6 // Debug Directory 调试表 #define IMAGE_DIRECTORY_ENTRY_COPYRIGHT 7 // (X86 usage) #define IMAGE_DIRECTORY_ENTRY_ARCHITECTURE 7 // Architecture Specific Data 缓存信息表:有一些保留字段必须是0 #define IMAGE_DIRECTORY_ENTRY_GLOBALPTR 8 // RVA of GP 全局指针偏移目录 #define IMAGE_DIRECTORY_ENTRY_TLS 9 // TLS Directory 线程局部存储(暂时未知) #define IMAGE_DIRECTORY_ENTRY_LOAD_CONFIG 10 // Load Configuration Directory 载入配置 #define IMAGE_DIRECTORY_ENTRY_BOUND_IMPORT 11 // Bound Import Directory in headers 存储一些API的绑定输入信息 #define IMAGE_DIRECTORY_ENTRY_IAT 12 // Import Address Table 导入地址表：导入函数的地址 #define IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT 13 // Delay Load Import Descriptors #define IMAGE_DIRECTORY_ENTRY_COM_DESCRIPTOR 14 // COM Runtime descriptor com运行时的目录 //最后一个保留 导出表 当PE文件执行时 Windows装载器将文件装入内存并将导入表中登记的DLL文件一并装入，再根据DLL文件中函数的导出信息对可执行文件的导入表(IAT)进行修正。\n导出函数的DLL文件中，导出信息被保存在导出表，导出表就是记载着动态链接库的一些导出信息。通过导出表，DLL文件可以向系统提供导出函数的名称、序号和入口地址等信息，以便Windows装载器能够通过这些信息来完成动态链接的整个过程。\n导出函数存储在PE文件的导出表里，导出表的位置存放在PE文件头中的数据目录表中，与导出表对应的项目是数据目录中的首个IMAGE_DATA_DIRECTORY结构，从这个结构的VirtualAddress字段得到的就是导出表的RVA，导出表同样可以使用函数名或序号这两种方法导出函数。\n数据目录项的第一个结构，就是 Export 导出表，只有一个IMAGE_EXPORT_DIRECTORY结构，结构如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 typedef struct _IMAGE_EXPORT_DIRECTORY { DWORD Characteristics; DWORD TimeDateStamp; //时间戳 WORD MajorVersion; WORD MinorVersion; DWORD Name; //指向导出表文件名字符串 DWORD Base; //导出函数起始序号 DWORD NumberOfFunctions; //所有导出函数的个数（导出函数最大序号 - 起始序号 + 1） DWORD NumberOfNames; //以函数名字导出的函数的个数（即有函数名的函数个数） DWORD AddressOfFunctions; //导出函数地址表的RVA DWORD AddressOfNames; //导出函数名称表的RVA DWORD AddressOfNameOrdinals; //导出函数序号表的RVA } IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY; 导出函数查找\n名称导出：名字所在地址下标即序号地址下标，取出对应序号即函数地址下标\n序号导出：导出序号 - 起始序号 = 对应函数地址下标\n练习：\n编写程序打印导出表信息\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 VOID DisplayExportTable(){ DWORD dwSize = 0; DWORD dwFOA = 0; DWORD dwSizeOfDirectory = 0; LPVOID pFileBuffer = NULL; PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_DATA_DIRECTORY pDataDirectory = NULL; PIMAGE_EXPORT_DIRECTORY pExportDirectory = NULL; dwSize = ReadPEFile(path, \u0026amp;pFileBuffer); if(dwSize == 0 || !pFileBuffer){ printf(\u0026#34;Fail to read file\\n\u0026#34;); return ; } if(!isPE(pFileBuffer)){ printf(\u0026#34;Is not PE file!\\n\u0026#34;); return ; } pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer; pNTHeader = (PIMAGE_NT_HEADERS)((BYTE*)pFileBuffer + pDosHeader-\u0026gt;e_lfanew); pPEHeader = \u0026amp;pNTHeader-\u0026gt;FileHeader; if (pNTHeader-\u0026gt;FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) { PIMAGE_OPTIONAL_HEADER64 pOptionHeader = (PIMAGE_OPTIONAL_HEADER64)\u0026amp;pNTHeader-\u0026gt;OptionalHeader; dwSizeOfDirectory = pOptionHeader-\u0026gt;NumberOfRvaAndSizes; pDataDirectory = pOptionHeader-\u0026gt;DataDirectory; } else { PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)\u0026amp;pNTHeader-\u0026gt;OptionalHeader; dwSizeOfDirectory = pOptionHeader-\u0026gt;NumberOfRvaAndSizes; pDataDirectory = pOptionHeader-\u0026gt;DataDirectory; } dwFOA = RvaToFoa(pFileBuffer, pDataDirectory[0].VirtualAddress);\t//定位导出表 pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)pFileBuffer + dwFOA); if(pExportDirectory-\u0026gt;Name == NULL || pExportDirectory-\u0026gt;NumberOfFunctions == 0){ printf(\u0026#34;ExportDirectory is NULL\\n\u0026#34;); return ; } printf(\u0026#34;***************ExportDirectory***************\\n\u0026#34;); printf(\u0026#34;导出表RVA:0x%x\\n\u0026#34;, pDataDirectory[0].VirtualAddress); printf(\u0026#34;导出表大小:0x%x字节\\n\u0026#34;, pDataDirectory[0].Size); printf(\u0026#34;导出表FOA：0x%x\\n\u0026#34;, dwFOA); printf(\u0026#34;TimeDataStamp(经加密):0x%x\\n\u0026#34;, pExportDirectory-\u0026gt;TimeDateStamp); printf(\u0026#34;Name(导出表文件名字符串):%s\\n\u0026#34;, (BYTE*)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-\u0026gt;Name)); printf(\u0026#34;Base(函数起始序号)：%d\\n\u0026#34;, pExportDirectory-\u0026gt;Base); printf(\u0026#34;NumberOfFunction(导出函数总数):0x%x\\n\u0026#34;, pExportDirectory-\u0026gt;NumberOfFunctions); printf(\u0026#34;NumberOfNames(以名称导出函数的总数)：0x%x\\n\u0026#34;, pExportDirectory-\u0026gt;NumberOfNames); printf(\u0026#34;AddressOfFunctions(导出函数地址表RVA)：0x%x\\n\u0026#34;, pExportDirectory-\u0026gt;AddressOfFunctions); printf(\u0026#34;AddressOfNames(导出函数名称表RVA)：0x%x\\n\u0026#34;, pExportDirectory-\u0026gt;AddressOfNames); printf(\u0026#34;AddressOfNameOrdinals(导出函数序号表RVA)：0x%x\\n\u0026#34;, pExportDirectory-\u0026gt;AddressOfNameOrdinals); printf(\u0026#34;-------AddressOfFunctions-------\\n\u0026#34;); int i = 0; PDWORD AddressOfFunction = (PDWORD)((BYTE*)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-\u0026gt;AddressOfFunctions)); for(i = 0; i \u0026lt; pExportDirectory-\u0026gt;NumberOfFunctions; i++){ dwFOA = (DWORD)(RvaToFoa(pFileBuffer, *AddressOfFunction)); printf(\u0026#34;下标:%d\\t函数地址RVA:0x%x\\tFOA:0x%x\\n\u0026#34;, i, *(AddressOfFunction), dwFOA); AddressOfFunction++; } printf(\u0026#34;-------NameOfFunctions-------\\n\u0026#34;); PDWORD AddressOfNames = (PDWORD)((BYTE*)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-\u0026gt;AddressOfNames)); for(i = 0; i \u0026lt; pExportDirectory-\u0026gt;NumberOfNames; i++){ char* name = (char*)((BYTE*)pFileBuffer + RvaToFoa(pFileBuffer, *AddressOfNames)); printf(\u0026#34;下标:%d\\t函数名称：%s\\t\\t名称RVA:0x%x\\n\u0026#34;, i, name, *AddressOfNames); AddressOfNames++; } printf(\u0026#34;-------OrdinalsOfFunctions-------\\n\u0026#34;); PWORD AddressOfNameOrdinals = (PWORD)((BYTE*)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-\u0026gt;AddressOfNameOrdinals)); for(i = 0; i \u0026lt; pExportDirectory-\u0026gt;NumberOfNames; i++){ printf(\u0026#34;下标:%d\\t函数序号(加Base)：%d\\n\u0026#34;, i, *AddressOfNameOrdinals + pExportDirectory-\u0026gt;Base); AddressOfNameOrdinals++; } } 按函数名获取函数地址GetFunctionAddrByName(函数名指针)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 DWORD GetFunctionAddrByName(IN char* pFunctionName){ DWORD dwSize = 0; DWORD dwFOA = 0; DWORD dwSizeOfDirectory = 0; LPVOID pFileBuffer = NULL; PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_DATA_DIRECTORY pDataDirectory = NULL; PIMAGE_EXPORT_DIRECTORY pExportDirectory = NULL; dwSize = ReadPEFile(path, \u0026amp;pFileBuffer); if(dwSize == 0 || !pFileBuffer){ printf(\u0026#34;Fail to read file\\n\u0026#34;); return -1; } if(!isPE(pFileBuffer)){ printf(\u0026#34;Is not PE file!\\n\u0026#34;); return -1; } pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer; pNTHeader = (PIMAGE_NT_HEADERS)((BYTE*)pFileBuffer + pDosHeader-\u0026gt;e_lfanew); pPEHeader = \u0026amp;pNTHeader-\u0026gt;FileHeader; if (pNTHeader-\u0026gt;FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) { PIMAGE_OPTIONAL_HEADER64 pOptionHeader = (PIMAGE_OPTIONAL_HEADER64)\u0026amp;pNTHeader-\u0026gt;OptionalHeader; dwSizeOfDirectory = pOptionHeader-\u0026gt;NumberOfRvaAndSizes; pDataDirectory = pOptionHeader-\u0026gt;DataDirectory; } else { PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)\u0026amp;pNTHeader-\u0026gt;OptionalHeader; dwSizeOfDirectory = pOptionHeader-\u0026gt;NumberOfRvaAndSizes; pDataDirectory = pOptionHeader-\u0026gt;DataDirectory; } dwFOA = RvaToFoa(pFileBuffer, pDataDirectory[0].VirtualAddress);\t//定位导出表 pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)pFileBuffer + dwFOA); if(pExportDirectory-\u0026gt;Name == NULL || pExportDirectory-\u0026gt;NumberOfFunctions == 0){ printf(\u0026#34;ExportDirectory is NULL\\n\u0026#34;); return -1; } DWORD i, idx, f = 1; PDWORD AddressOfNames = (PDWORD)((BYTE*)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-\u0026gt;AddressOfNames)); for(i = 0; i \u0026lt; pExportDirectory-\u0026gt;NumberOfNames; i++){ char* name = (char*)((BYTE*)pFileBuffer + RvaToFoa(pFileBuffer, *AddressOfNames)); if(!strcmp(name, pFunctionName)){ f = 0; break; } AddressOfNames++; } if(f){ printf(\u0026#34;Notfound addr by name\\n\u0026#34;); return -1; } PWORD AddressOfNameOrdinals = (PWORD)((BYTE*)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-\u0026gt;AddressOfNameOrdinals)); idx = AddressOfNameOrdinals[i];\t//名称下标对应函数序号（真正导出序号 = idx + Base） PDWORD AddressOfFunction = (PDWORD)((BYTE*)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-\u0026gt;AddressOfFunctions)); return AddressOfFunction[idx]; } 按函数导出序号获取函数地址GetFunctionAddrByOrdinals(函数导出序号)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 DWORD GetFunctionAddrByOrdinals(IN DWORD pFunctionOrdinals){ DWORD dwSize = 0; DWORD dwFOA = 0; DWORD dwSizeOfDirectory = 0; LPVOID pFileBuffer = NULL; PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_DATA_DIRECTORY pDataDirectory = NULL; PIMAGE_EXPORT_DIRECTORY pExportDirectory = NULL; dwSize = ReadPEFile(path, \u0026amp;pFileBuffer); if(dwSize == 0 || !pFileBuffer){ printf(\u0026#34;Fail to read file\\n\u0026#34;); return -1; } if(!isPE(pFileBuffer)){ printf(\u0026#34;Is not PE file!\\n\u0026#34;); return -1; } pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer; pNTHeader = (PIMAGE_NT_HEADERS)((BYTE*)pFileBuffer + pDosHeader-\u0026gt;e_lfanew); pPEHeader = \u0026amp;pNTHeader-\u0026gt;FileHeader; if (pNTHeader-\u0026gt;FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) { PIMAGE_OPTIONAL_HEADER64 pOptionHeader = (PIMAGE_OPTIONAL_HEADER64)\u0026amp;pNTHeader-\u0026gt;OptionalHeader; dwSizeOfDirectory = pOptionHeader-\u0026gt;NumberOfRvaAndSizes; pDataDirectory = pOptionHeader-\u0026gt;DataDirectory; } else { PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)\u0026amp;pNTHeader-\u0026gt;OptionalHeader; dwSizeOfDirectory = pOptionHeader-\u0026gt;NumberOfRvaAndSizes; pDataDirectory = pOptionHeader-\u0026gt;DataDirectory; } dwFOA = RvaToFoa(pFileBuffer, pDataDirectory[0].VirtualAddress);\t//定位导出表 pExportDirectory = (PIMAGE_EXPORT_DIRECTORY)((BYTE*)pFileBuffer + dwFOA); if(pExportDirectory-\u0026gt;Name == NULL || pExportDirectory-\u0026gt;NumberOfFunctions == 0){ printf(\u0026#34;ExportDirectory is NULL\\n\u0026#34;); return -1; } PDWORD AddressOfFunction = (PDWORD)((BYTE*)pFileBuffer + RvaToFoa(pFileBuffer, pExportDirectory-\u0026gt;AddressOfFunctions)); if(pFunctionOrdinals - pExportDirectory-\u0026gt;Base \u0026gt;= pExportDirectory-\u0026gt;NumberOfFunctions){ printf(\u0026#34;The ordinals is wrong\u0026#34;); return -1; } return AddressOfFunction[pFunctionOrdinals - pExportDirectory-\u0026gt;Base]; } 相当于GetProAddress()\n重定位表 1.程序加载过程\n一般情况下，exe可按照自身的ImageBase加载，有自己的4GB虚拟空间，而dll需加载到相应exe进程空间\n模块对齐：10000h 即64K\n2.为什么要用重定位表\n全局变量编译时生成的地址 = ImageBase + RVA，这个地址直接写入文件中\n若没有加载到预定位置，则直接按文件地址会出错\n需要加载的dll所对应的ImageBase有可能相同，会被加载到其他地址\n因此，dll大多都有重定位表，而exe不一定有\n一旦某个模块没有按照自身ImageBase进行加载，那么类似上述地址都需要修正\n3.重定位表的结构分析\n数据目录项第六个结构，就是重定位表，记录了需要重定位的函数地址的RVA\n1 2 3 4 5 6 typedef struct _IMAGE_BASE_RELOCATION { DWORD VirtualAddress;\t//RVA DWORD SizeOfBlock;\t//重定位块大小 //WORD TypeOffset[1];\t//虽然被注释，但仍存在，其16位大小，前四位为Type，后十二位为Offest } IMAGE_BASE_RELOCATION; typedef IMAGE_BASE_RELOCATION UNALIGNED * PIMAGE_BASE_RELOCATION; 通过IMAGE_DATA_DIRECTORY结构的VirtualAddress属性找到第一个IMAGE_BASE_RELOCATION 判断一共有几块数据：最后一个结构的VirtualAddress与SizeOfBlock均为0 具体项 宽度：2字节 内存中的页大小是1000h，也就是2的12次方就可以表示一个页内所有的偏移地址，具体项的宽度是16位，高四位代表类型：值为3代表需要修改的数据的RVA；值为0代表用于数据对齐的数据，可以不用修改\nVirtualAddress 宽度：4字节 当前这一块的数据，每一个低12位的值 + VirtualAddress才是真正需要修复地址的RVA\nSizeOfBlock 宽度：4字节 当前块总大小，具体项数目 = (SizeOfBlock - 8) / 2\n4.打印重定位表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 VOID DisplayRelocTable(){ DWORD dwSize = 0; DWORD dwFOA = 0; DWORD dwSizeOfDirectory = 0; LPVOID pFileBuffer = NULL; PWORD pRelocData = NULL; PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_DATA_DIRECTORY pDataDirectory = NULL; PIMAGE_BASE_RELOCATION pRelocTable = NULL; dwSize = ReadPEFile(path, \u0026amp;pFileBuffer); if(dwSize == 0 || !pFileBuffer){ printf(\u0026#34;Fail to read file\\n\u0026#34;); return ; } if(!isPE(pFileBuffer)){ printf(\u0026#34;Is not PE file!\\n\u0026#34;); return ; } pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer; pNTHeader = (PIMAGE_NT_HEADERS)((BYTE*)pFileBuffer + pDosHeader-\u0026gt;e_lfanew); pPEHeader = \u0026amp;pNTHeader-\u0026gt;FileHeader; if (pNTHeader-\u0026gt;FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) { PIMAGE_OPTIONAL_HEADER64 pOptionHeader = (PIMAGE_OPTIONAL_HEADER64)\u0026amp;pNTHeader-\u0026gt;OptionalHeader; dwSizeOfDirectory = pOptionHeader-\u0026gt;NumberOfRvaAndSizes; pDataDirectory = pOptionHeader-\u0026gt;DataDirectory; } else { PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)\u0026amp;pNTHeader-\u0026gt;OptionalHeader; dwSizeOfDirectory = pOptionHeader-\u0026gt;NumberOfRvaAndSizes; pDataDirectory = pOptionHeader-\u0026gt;DataDirectory; } dwFOA = RvaToFoa(pFileBuffer, pDataDirectory[5].VirtualAddress);\t//定位重定位表 pRelocTable = (PIMAGE_BASE_RELOCATION)((BYTE*)pFileBuffer + dwFOA); printf(\u0026#34;***************BaseRelocation***************\\n\u0026#34;); int i=1; while (pRelocTable-\u0026gt;VirtualAddress != 0 \u0026amp;\u0026amp; pRelocTable-\u0026gt;SizeOfBlock != 0){\t//遍历重定位表 printf(\u0026#34;RelocTable[%d]\\tRVA:%0X, Size:%0X\\n\u0026#34;, i, pRelocTable-\u0026gt;VirtualAddress, pRelocTable-\u0026gt;SizeOfBlock); DWORD dwItems = ((pRelocTable-\u0026gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / 2); printf(\u0026#34;项目数:%X h / %d d\\r\\n\u0026#34;, dwItems, dwItems); pRelocData = (PWORD)((BYTE*)pRelocTable + 0x8); for (int i = 0; i \u0026lt; dwItems; i++ ){ if (*(pRelocData + i) \u0026gt;\u0026gt; 12 == IMAGE_REL_BASED_HIGHLOW){\t//IMAGE_REL_BASED_HIGHLOW = 3 DWORD dwRva = ((*(pRelocData + i) \u0026amp; 0x0fff) + pRelocTable-\u0026gt;VirtualAddress); DWORD dwFoa = RvaToFoa(pFileBuffer, dwRva); DWORD dwFarCall = *(DWORD*)(pFileBuffer + dwFoa); printf(\u0026#34;RVA:0x%X\\tFOA:0x%X\\tFarCall:0x%X\\t(HIGHLOW)\\n\u0026#34;, dwRva, dwFoa, dwFarCall);\t//需要重定位的函数 }else{ printf(\u0026#34;-(ABSLUTE)\\r\\n\u0026#34;);\t//类型非3的提示 } } pRelocTable = (PIMAGE_BASE_RELOCATION)((BYTE*)pRelocTable + pRelocTable-\u0026gt;SizeOfBlock); i++; } } 移动导出表 - 重定位表 为什么要移动各种表\n1.这些表是编译器生成的，里面存储了非常重要的信息\n2.在程序启动的时候，系统会根据这些表做初始化的工作：比如，将用到的dll中的函数地址存储到IAT表中\n3.为了保护程序，可以对.exe的二进制代码进行加密操作，但若各种表的信息与客户的代码和数据混在一起，进行加密，系统初始化会出问题\n4.学会移动各种表，是对程序加密/破解的基础\n移动导出表 在dll中新增节，并返回FOA 依次复制AddressOfFunctions、AddressOfNameOrdinals、AddressOfNames 复制所有函数名，复制时修复AddressOfNames，同时复制dll名，并修改导出表Name字段 复制IMAGE_EXPORT_DIRECTORY，并修复AddressOfFunctions、AddressOfNameOrdinals、AddressOfNames 修复目录项中的值，指向新的IMAGE_EXPORT_DIRECTORY 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 // 移动导出表函数 BOOL MoveExportTable(LPVOID* ppFileBuffer, DWORD* pFileSize) { IMAGE_DOS_HEADER* pDosHeader = (IMAGE_DOS_HEADER*)*ppFileBuffer; IMAGE_NT_HEADERS* pNtHeaders = (IMAGE_NT_HEADERS*)((BYTE*)*ppFileBuffer + pDosHeader-\u0026gt;e_lfanew); // 获取导出表目录项 IMAGE_DATA_DIRECTORY* exportDir = \u0026amp;pNtHeaders-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT]; if (exportDir-\u0026gt;VirtualAddress == 0 || exportDir-\u0026gt;Size == 0) { printf(\u0026#34;No export table found\\n\u0026#34;); return FALSE; } // 获取导出表结构 DWORD exportFoa = RvaToFoa(*ppFileBuffer, exportDir-\u0026gt;VirtualAddress); IMAGE_EXPORT_DIRECTORY* pExportDir = (IMAGE_EXPORT_DIRECTORY*)((BYTE*)*ppFileBuffer + exportFoa); // 获取DLL名称 DWORD dllNameFoa = RvaToFoa(*ppFileBuffer, pExportDir-\u0026gt;Name); char* dllName = (char*)((BYTE*)*ppFileBuffer + dllNameFoa); DWORD dllNameLen = strlen(dllName) + 1; // 包括null终止符 // 计算导出表总大小 DWORD totalSize = sizeof(IMAGE_EXPORT_DIRECTORY); totalSize += pExportDir-\u0026gt;NumberOfFunctions * sizeof(DWORD); // AddressOfFunctions totalSize += pExportDir-\u0026gt;NumberOfNames * sizeof(DWORD); // AddressOfNames totalSize += pExportDir-\u0026gt;NumberOfNames * sizeof(WORD); // AddressOfNameOrdinals // 计算函数名字符串总长度 DWORD* nameRVAs = (DWORD*)((BYTE*)*ppFileBuffer + RvaToFoa(*ppFileBuffer, pExportDir-\u0026gt;AddressOfNames)); for (DWORD i = 0; i \u0026lt; pExportDir-\u0026gt;NumberOfNames; i++) { DWORD nameFoa = RvaToFoa(*ppFileBuffer, nameRVAs[i]); totalSize += strlen((char*)*ppFileBuffer + nameFoa) + 1; // 字符串+null终止符 } // 添加DLL名称长度 totalSize += dllNameLen; // 添加新节 DWORD newSectionFoa = AddNewSection(ppFileBuffer, pFileSize, \u0026#34;.edata\u0026#34;, totalSize, IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ); if (!newSectionFoa) { printf(\u0026#34;Failed to add new section for export table\\n\u0026#34;); return FALSE; } // 获取新节RVA DWORD newSectionRva = FoaToRva(*ppFileBuffer, newSectionFoa); // 准备复制指针 BYTE* newSectionStart = (BYTE*)*ppFileBuffer + newSectionFoa; BYTE* currentPos = newSectionStart; // 1. 复制AddressOfFunctions数组 DWORD* srcFunctions = (DWORD*)((BYTE*)*ppFileBuffer + RvaToFoa(*ppFileBuffer, pExportDir-\u0026gt;AddressOfFunctions)); DWORD* destFunctions = (DWORD*)currentPos; memcpy(destFunctions, srcFunctions, pExportDir-\u0026gt;NumberOfFunctions * sizeof(DWORD)); DWORD newFunctionsRva = newSectionRva + (DWORD)((BYTE*)destFunctions - newSectionStart); currentPos += pExportDir-\u0026gt;NumberOfFunctions * sizeof(DWORD); // 2. 复制AddressOfNameOrdinals数组 WORD* srcOrdinals = (WORD*)((BYTE*)*ppFileBuffer + RvaToFoa(*ppFileBuffer, pExportDir-\u0026gt;AddressOfNameOrdinals)); WORD* destOrdinals = (WORD*)currentPos; memcpy(destOrdinals, srcOrdinals, pExportDir-\u0026gt;NumberOfNames * sizeof(WORD)); DWORD newOrdinalsRva = newSectionRva + (DWORD)((BYTE*)destOrdinals - newSectionStart); currentPos += pExportDir-\u0026gt;NumberOfNames * sizeof(WORD); // 3. 复制AddressOfNames数组和函数名字符串 DWORD* srcNames = (DWORD*)((BYTE*)*ppFileBuffer + RvaToFoa(*ppFileBuffer, pExportDir-\u0026gt;AddressOfNames)); DWORD* destNames = (DWORD*)currentPos; currentPos += pExportDir-\u0026gt;NumberOfNames * sizeof(DWORD); for (DWORD i = 0; i \u0026lt; pExportDir-\u0026gt;NumberOfNames; i++) { // 复制字符串 DWORD nameFoa = RvaToFoa(*ppFileBuffer, srcNames[i]); char* srcName = (char*)*ppFileBuffer + nameFoa; char* destName = (char*)currentPos; DWORD nameLen = strlen(srcName) + 1; memcpy(destName, srcName, nameLen); // 更新AddressOfNames数组 destNames[i] = newSectionRva + (DWORD)(currentPos - newSectionStart); currentPos += nameLen; } DWORD newNamesRva = newSectionRva + (DWORD)((BYTE*)destNames - newSectionStart); // 4. 复制DLL名称字符串 char* newDllName = (char*)currentPos; memcpy(newDllName, dllName, dllNameLen); DWORD newDllNameRva = newSectionRva + (DWORD)(currentPos - newSectionStart); currentPos += dllNameLen; // 5. 复制IMAGE_EXPORT_DIRECTORY结构 IMAGE_EXPORT_DIRECTORY* destExportDir = (IMAGE_EXPORT_DIRECTORY*)currentPos; memcpy(destExportDir, pExportDir, sizeof(IMAGE_EXPORT_DIRECTORY)); // 修复导出表指针 destExportDir-\u0026gt;AddressOfFunctions = newFunctionsRva; destExportDir-\u0026gt;AddressOfNames = newNamesRva; destExportDir-\u0026gt;AddressOfNameOrdinals = newOrdinalsRva; destExportDir-\u0026gt;Name = newDllNameRva; // 更新DLL名称的RVA // 6. 更新数据目录 DWORD newExportDirRva = newSectionRva + (DWORD)(currentPos - newSectionStart); pNtHeaders-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_EXPORT].VirtualAddress = newExportDirRva; return TRUE; } 移动重定位表 循环遍历重定位表的大小，复制到新增节，然后修改目录项中VirtualAddress的值\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 // 移动重定位表函数 BOOL MoveRelocationTable(LPVOID* ppFileBuffer, DWORD* pFileSize) { IMAGE_DOS_HEADER* pDosHeader = (IMAGE_DOS_HEADER*)*ppFileBuffer; IMAGE_NT_HEADERS* pNTHeader = (IMAGE_NT_HEADERS*)((BYTE*)*ppFileBuffer + pDosHeader-\u0026gt;e_lfanew); PIMAGE_DATA_DIRECTORY pDataDirectory = NULL; if (pNTHeader-\u0026gt;FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) { PIMAGE_OPTIONAL_HEADER64 pOptionHeader = (PIMAGE_OPTIONAL_HEADER64)\u0026amp;pNTHeader-\u0026gt;OptionalHeader; pDataDirectory = pOptionHeader-\u0026gt;DataDirectory; } else { PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)\u0026amp;pNTHeader-\u0026gt;OptionalHeader; pDataDirectory = pOptionHeader-\u0026gt;DataDirectory; } // 获取导出表目录项 IMAGE_DATA_DIRECTORY* relocDir = \u0026amp;pDataDirectory[5]; if (relocDir-\u0026gt;VirtualAddress == 0 || relocDir-\u0026gt;Size == 0) { printf(\u0026#34;No relocation table found, %xh--%xh\\n\u0026#34;, relocDir-\u0026gt;VirtualAddress, relocDir-\u0026gt;Size); return FALSE; } // 添加新节 DWORD newSectionFoa = AddNewSection(ppFileBuffer, pFileSize, \u0026#34;.reloc\u0026#34;, relocDir-\u0026gt;Size, IMAGE_SCN_CNT_INITIALIZED_DATA | IMAGE_SCN_MEM_READ); if (!newSectionFoa) { printf(\u0026#34;Failed to add new section for relocation table\\n\u0026#34;); return FALSE; } // 获取重定位表FOA DWORD relocFoa = RvaToFoa(*ppFileBuffer, relocDir-\u0026gt;VirtualAddress); // 复制重定位表数据 memcpy((BYTE*)*ppFileBuffer + newSectionFoa, (BYTE*)*ppFileBuffer + relocFoa, relocDir-\u0026gt;Size); // 更新数据目录 DWORD newRelocRva = FoaToRva(*ppFileBuffer, newSectionFoa); relocDir-\u0026gt;VirtualAddress = newRelocRva; return TRUE; } 附加：\n修改dll的ImageBase，根据重定位表修正，然后存盘\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // 修改ImageBase并应用重定位修正 BOOL RebasePE(LPVOID pFileBuffer, DWORD newImageBase) { IMAGE_DOS_HEADER* pDosHeader = (IMAGE_DOS_HEADER*)pFileBuffer; IMAGE_NT_HEADERS* pNtHeaders = (IMAGE_NT_HEADERS*)((BYTE*)pFileBuffer + pDosHeader-\u0026gt;e_lfanew); PIMAGE_DATA_DIRECTORY pDataDirectory = NULL; DWORD oldImageBase = 0; if (pNtHeaders-\u0026gt;FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) { PIMAGE_OPTIONAL_HEADER64 pOptionHeader = (PIMAGE_OPTIONAL_HEADER64)\u0026amp;pNtHeaders-\u0026gt;OptionalHeader; oldImageBase = pOptionHeader-\u0026gt;ImageBase; pOptionHeader-\u0026gt;ImageBase = newImageBase; // 更新ImageBase pDataDirectory = pOptionHeader-\u0026gt;DataDirectory; } else { PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)\u0026amp;pNtHeaders-\u0026gt;OptionalHeader; oldImageBase = pOptionHeader-\u0026gt;ImageBase; pOptionHeader-\u0026gt;ImageBase = newImageBase; pDataDirectory = pOptionHeader-\u0026gt;DataDirectory; } // 如果新旧基址相同，不需要重定位 if (oldImageBase == newImageBase) { printf(\u0026#34;ImageBase unchanged (0x%08X), no rebasing needed\\n\u0026#34;, newImageBase); return TRUE; } printf(\u0026#34;ImageBase changed from 0x%08X to 0x%08X\\n\u0026#34;, oldImageBase, newImageBase); // 获取重定位表 IMAGE_DATA_DIRECTORY* relocDir = \u0026amp;pDataDirectory[IMAGE_DIRECTORY_ENTRY_BASERELOC]; if (relocDir-\u0026gt;VirtualAddress == 0 || relocDir-\u0026gt;Size == 0) { printf(\u0026#34;No relocation table found, skipping rebasing\\n\u0026#34;); return TRUE; } // 计算基址差值 DWORD_PTR delta = (DWORD_PTR)newImageBase - (DWORD_PTR)oldImageBase; // 获取重定位表起始位置 DWORD relocFoa = RvaToFoa(pFileBuffer, relocDir-\u0026gt;VirtualAddress); IMAGE_BASE_RELOCATION* pRelocTable = (IMAGE_BASE_RELOCATION*)((BYTE*)pFileBuffer + relocFoa); // 遍历重定位块 int i=1; while (pRelocTable-\u0026gt;VirtualAddress != 0 \u0026amp;\u0026amp; pRelocTable-\u0026gt;SizeOfBlock != 0){ //遍历重定位表 DWORD dwItems = ((pRelocTable-\u0026gt;SizeOfBlock - sizeof(IMAGE_BASE_RELOCATION)) / 2); PWORD pRelocData = (PWORD)((BYTE*)pRelocTable + 0x8); for (int i = 0; i \u0026lt; dwItems; i++ ){ if (*(pRelocData + i) \u0026gt;\u0026gt; 12 == IMAGE_REL_BASED_HIGHLOW){ //IMAGE_REL_BASED_HIGHLOW = 3 DWORD dwRva = ((*(pRelocData + i) \u0026amp; 0x0fff) + pRelocTable-\u0026gt;VirtualAddress); DWORD dwFoa = RvaToFoa(pFileBuffer, dwRva); DWORD* pFuncall = (DWORD*)(pFileBuffer + dwFoa); *pFuncall += delta; //重定位 } } pRelocTable = (PIMAGE_BASE_RELOCATION)((BYTE*)pRelocTable + pRelocTable-\u0026gt;SizeOfBlock); i++; } return TRUE; } IAT表 重定位表（Relocation Table）和导入地址表（IAT - Import Address Table）在 Windows PE 文件格式中都扮演着关键角色，但它们处理的是不同阶段、不同类型的地址问题。它们之间的关系可以概括为：重定位表负责修正模块（DLL/EXE）内部代码和数据对自身地址的引用，而 IAT 负责存储模块调用其他模块（DLLs）中函数的实际地址。更重要的是，IAT 表项本身所在的内存地址，在模块被加载到非首选基址时，就需要通过重定位表来修正。\n理解重定位表如何帮助程序找到调用函数的地址，需要结合导入地址表一起来看。核心思想是：重定位表修正指向IAT项的指针，IAT项本身存储着最终的函数地址。\n以下是详细步骤：\n编译与链接时的假设： 编译器在生成调用外部DLL函数（如MessageBoxA）的代码时，并不知道这个函数最终会加载到内存的哪个地址。 它生成一条间接调用指令，例如：call dword ptr [0x00403000]（32位示例）。 这里的0x00403000是一个硬编码的地址，是编译器/链接器假设的DLL加载基址（称为ImageBase）加上一个固定偏移量（.idata节或IAT的RVA）。在这个例子中，0x00403000指向导入地址表中的一个位置。 导入地址表的角色： IAT是PE文件中一个专门的数据结构（通常在.idata节）。 在程序加载完成之前，IAT中存储的并不是函数的真实地址，而是： 函数名的指针（用于按名称导入）。 或者函数的序号（用于按序号导入）。 它的目的是在运行时被Windows加载器填充。 加载时的挑战： 程序启动时，Windows加载器尝试将DLL加载到它的ImageBase（例如0x10000000）。 如果这个地址没有被其他模块占用，加载成功。DLL的代码和数据就位于预期的地址。 但是，如果ImageBase地址已被占用（很常见），加载器必须将DLL重定位到另一个空闲的基地址（例如0x15000000）。 重定位意味着DLL中所有基于ImageBase的绝对地址引用（代码和数据中的指针）都不再正确，它们需要被调整一个差值 Delta = ActualBase - ImageBase（例如 0x15000000 - 0x10000000 = 0x05000000）。 重定位表的作用： 重定位表（.reloc节）就是告诉加载器：“我的DLL代码和数据中，哪些位置存储的是需要根据加载基址调整的绝对指针”。 它包含一系列条目，每个条目指定一个内存页（4KB对齐）和该页内所有需要修正的偏移量列表。 关键点： 指向IAT项的指针（比如例子中call dword ptr [0x00403000]里的0x00403000）就是需要被修正的绝对地址之一！它是在编译时基于ImageBase计算出来的，如果DLL被重定位了，这个值就错了。 加载器如何修正调用函数的地址： 解析IAT (填充函数真实地址)： 无论DLL是否被重定位，加载器首先都会解析所有导入函数。它找到目标DLL（可能也需要重定位），加载它，找到MessageBoxA的实际内存地址（例如0x15012345），然后将这个真实地址写回主程序的IAT中对应的位置（假设这个位置在IAT中的偏移是固定的，由链接器确定）。 应用重定位 (修正指向IAT的指针)： 加载器检查主程序是否需要重定位（如果主程序的ImageBase被占用）。 如果需要，加载器读取主程序的重定位表。 在重定位表中，它会找到像0x00403000这样的地址（位于某个.reloc条目指定的页内）。 加载器计算Delta（实际加载基址 - ImageBase）。 加载器将这个Delta值加到存储在0x00403000这个内存位置的值上吗？不对！ 正确的操作是： 加载器将Delta值加到指向IAT项的指针本身，也就是加到0x00403000这个地址上（更准确地说，是加到包含0x00403000这个地址值的那个内存位置的内容上）。0x00403000这个地址值本身是基于ImageBase计算出来的，它指向IAT中的一个槽位。重定位后，主程序的实际基址变了，这个指向IAT槽位的指针0x00403000也必须加上Delta才能指向正确的内存位置（即新的IAT槽位地址）。 间接调用生效： 假设主程序被重定位到0x00450000（原ImageBase是0x00400000，Delta = 0x00050000）。 指向IAT项的原指针是0x00403000。 加载器通过重定位表找到这个指针的位置（假设是主程序代码段中的0x00401023处存储着值0x00403000，即0x00401023 = [0x00403000]，重定位表中存的是0x0 + 0x1023这个RVA）。 加载器将存储在0x00001023 + 0x00450000处的值修改为 0x00403000 + 0x00050000 = 0x00453000。 现在，调用指令call dword ptr [0x00453000] 就能正确执行了： 它去0x00453000（这是重定位后IAT中MessageBoxA条目所在的新地址）读取内容。 这个新地址0x00453000处的内容，在步骤1中已经被加载器填充为MessageBoxA的真实地址0x15012345。 因此，CPU执行call [0x00453000]（中间有个jmp dword ptr [0x15012345]）最终会跳转到0x15012345，即MessageBoxA函数的入口点。 具体关系如下图\n导入表 实现：\n1.使用OD打开一个发布版的exe程序，定位到某个dll的API\n2.在没有加载的exe中找到这个位置，观察加载前后的区别\n数据目录项的第二个结构，就是 Import 导入表，从IMAGE_DATA_DIRECTORY字段得到的是导入表的RVA值，如果在内存中查找导入表，那么将RVA值加上PE文件装入的基址就是实际的地址。\n找到了数据目录结构，既能够找到导入表，导入表由一系列的IMAGE_IMPORT_DESCRIPTOR结构组成，结构的数量取决于程序需要使用的DLL文件数量，每个结构对应一个DLL文件，在所有结构的最后，由一个内容全为0的IMAGE_IMPORT_DESCRIPTOR结构作为结束标志，表结构定义如下：\n（使用到几个dll就有几个导入表）\n1 2 3 4 5 6 7 8 9 10 11 typedef struct _IMAGE_IMPORT_DESCRIPTOR { union { DWORD Characteristics; DWORD OriginalFirstThunk; *\t// 包含指向IMAGE_THUNK_DATA(导入名称表INT)结构数组的RVA } DUMMYUNIONNAME; DWORD TimeDateStamp; // 时间戳：当可执行文件不与被输入的DLL进行绑定时，此字段为0 若绑定，则为-1（0xffffffff） DWORD ForwarderChain; // 第一个被转向的API的索引 DWORD Name; // 指向被输入的DLL的ASCII字符串的RVA DWORD FirstThunk; * // 指向导入地址表(IAT)的RVA } IMAGE_IMPORT_DESCRIPTOR; typedef IMAGE_IMPORT_DESCRIPTOR UNALIGNED * IMAGE_IMPORT_DESCRIPTOR; OriginalFirstThunk和FirstThunk字段是相同的，他们都指向一个包含IMAGE_THUNK_DATA结构的数组，数组中每个IMAGE_THUNK_DATA结构定义了一个导入函数的具体信息，数组的最后以一个内容全为0的IMAGE_THUNK_DATA结构作为结束，该结构的定义如下：\n判断最高位是否为1 如果是，那么去除最高位的值就是函数的导出序号；如果不是，那么这个值是一个指向IMAGE_IMPORT_BY_NAME的RVA\n1 2 3 4 5 6 7 8 9 typedef struct _IMAGE_THUNK_DATA32 { union { DWORD ForwarderString;\t// PBYTE DWORD Function;\t// PDWORD DWORD Ordinal;\t// 导出序号 PIMAGE_IMPORT_BY_NAME AddressOfData; // 指向IMAGE_IMPORT_BY_NAME的RVA（指针都是4字节） } u1; } IMAGE_THUNK_DATA32; typedef IMAGE_THUNK_DATA32 * PIMAGE_THUNK_DATA32; 从上方的结构定义不难看出，这是一个双字共用体结构，当结构的最高位为1时，表示函数是以序号的方式导入的，这时双字的低位就是函数的序号，当双字最高位为0时，表示函数以函数名方式导入，这时双字的值是一个RVA，指向一个用来定义导入函数名称的IMAGE_IMPORT_BY_NAME结构，此结构定义如下：\n1 2 3 4 typedef struct _IMAGE_IMPORT_BY_NAME { WORD Hint;\t// 函数序号 CHAR Name[];\t// 导入函数的名称（指针4字节） } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME; PE加载前\nPE加载后，调用GetProcAddr()\n打印导入表\n1.定位导入表\n2.输出dll名字\n3.遍历OriginalFirstThunk\n4.遍历FirstThunk\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 VOID DisplayImportTable(){ DWORD dwSize = 0; DWORD dwFOA = 0; DWORD dwSizeOfDirectory = 0; LPVOID pFileBuffer = NULL; PWORD pRelocData = NULL; PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_DATA_DIRECTORY pDataDirectory = NULL; PIMAGE_IMPORT_DESCRIPTOR pImportDescriptor = NULL; dwSize = ReadPEFile(path, \u0026amp;pFileBuffer); if(dwSize == 0 || !pFileBuffer){ printf(\u0026#34;Fail to read file\\n\u0026#34;); return ; } if(!isPE(pFileBuffer)){ printf(\u0026#34;Is not PE file!\\n\u0026#34;); return ; } pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer; pNTHeader = (PIMAGE_NT_HEADERS)((BYTE*)pFileBuffer + pDosHeader-\u0026gt;e_lfanew); pPEHeader = \u0026amp;pNTHeader-\u0026gt;FileHeader; if (pNTHeader-\u0026gt;FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) { PIMAGE_OPTIONAL_HEADER64 pOptionHeader = (PIMAGE_OPTIONAL_HEADER64)\u0026amp;pNTHeader-\u0026gt;OptionalHeader; dwSizeOfDirectory = pOptionHeader-\u0026gt;NumberOfRvaAndSizes; pDataDirectory = pOptionHeader-\u0026gt;DataDirectory; } else { PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)\u0026amp;pNTHeader-\u0026gt;OptionalHeader; dwSizeOfDirectory = pOptionHeader-\u0026gt;NumberOfRvaAndSizes; pDataDirectory = pOptionHeader-\u0026gt;DataDirectory; } dwFOA = RvaToFoa(pFileBuffer, pDataDirectory[1].VirtualAddress);\t//定位导入表 pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)pFileBuffer + dwFOA); printf(\u0026#34;***************ImportDescriptor***************\\n\u0026#34;); while(!(pImportDescriptor-\u0026gt;FirstThunk == 0 \u0026amp;\u0026amp; pImportDescriptor-\u0026gt;OriginalFirstThunk == 0)){\t//遍历导入表 printf(\u0026#34;***%s***\\n\u0026#34;, (PBYTE)((BYTE*)pFileBuffer + RvaToFoa(pFileBuffer, pImportDescriptor-\u0026gt;Name))); printf(\u0026#34;-------OriginalFirstThunk-------\\n\u0026#34;); PDWORD pOriginalFirstThunk = (PDWORD)((BYTE*)pFileBuffer + RvaToFoa(pFileBuffer, pImportDescriptor-\u0026gt;OriginalFirstThunk)); printf(\u0026#34;%x - %x\\n\u0026#34;, pOriginalFirstThunk, *pOriginalFirstThunk); printf(\u0026#34;TimeDateStamp: %x\\n\u0026#34;, pImportDescriptor-\u0026gt;TimeDateStamp); while(*pOriginalFirstThunk){\t//遍历INT表 if(*pOriginalFirstThunk \u0026amp; IMAGE_ORDINAL_FLAG32){\t//IMAGE_ORDINAL_FLAG32 = 0x80000000 printf(\u0026#34;按序号导入：%x\\n\u0026#34;, (*pOriginalFirstThunk)\u0026amp;0x0FFFF); }else{ PIMAGE_IMPORT_BY_NAME pImageByName = (PIMAGE_IMPORT_BY_NAME)((BYTE*)pFileBuffer + RvaToFoa(pFileBuffer, *pOriginalFirstThunk)); printf(\u0026#34;按名称导入Hint-Name: %x-%s\\n\u0026#34;, pImageByName-\u0026gt;Hint, pImageByName-\u0026gt;Name); } //pOriginalFirstThunk = (PDWORD)((BYTE*)pOriginalFirstThunk + sizeof(IMAGE_THUNK_DATA32)); pOriginalFirstThunk++; } printf(\u0026#34;-------FirstThunk-------\\n\u0026#34;); PDWORD pFirstThunk = (PDWORD)((BYTE*)pFileBuffer + RvaToFoa(pFileBuffer, pImportDescriptor-\u0026gt;FirstThunk)); printf(\u0026#34;%x - %x\\n\u0026#34;, pFirstThunk, *pFirstThunk); while(*pFirstThunk){ if(*pFirstThunk \u0026amp; IMAGE_ORDINAL_FLAG32){\t//IMAGE_ORDINAL_FLAG32 = 0x80000000 printf(\u0026#34;按序号导入：%x\\n\u0026#34;, (*pFirstThunk)\u0026amp;0x0FFFF); }else{ PIMAGE_IMPORT_BY_NAME pImageByName = (PIMAGE_IMPORT_BY_NAME)((BYTE*)pFileBuffer + RvaToFoa(pFileBuffer, *pFirstThunk)); printf(\u0026#34;按名称导入Hint-Name: %x-%s\\n\u0026#34;, pImageByName-\u0026gt;Hint, pImageByName-\u0026gt;Name); } //pFirstThunk = (PDWORD)((BYTE*)pFirstThunk + sizeof(IMAGE_THUNK_DATA32)); pFirstThunk++; } pImportDescriptor = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)pImportDescriptor + sizeof(IMAGE_IMPORT_DESCRIPTOR)); } free(pFileBuffer); } 绑定导入表 PE加载exe相关dll时，首先会根据IMAGE_IMPORT_DESCRIPTOR结构中的TimeDateStamp来判断是否要重新计算IAT\nTimeDateStamp为0则IAT未绑定；若TimeDateStamp为-1则IAT已绑定 而真正绑定时间为IMAGE_BOUND_IMPORT_DESCRIPTOR的TimeDateStamp\n绑定导入表位于数据目录项的第12项\n1 2 3 4 5 struct _IMAGE_BOUND_IMPORT_DESCRIPTOR{\tDWORD TimeDateStamp;\t//时间戳\tWORD OffsetModuleName;\t//DLL的名字RVA（加第一个结构中RVA才是字符串真正RVA，详见下面）\tWORD NumberOfModuleForwarderRefs; //这个绑定导入表结构后面还有几个_IMAGE_BOUND_FORWARDER_REF这种结构\t} IMAGE_BOUND_IMPORT_DESCRIPTOR, *PIMAGE_BOUND_IMPORT_DESCRIPTOR; //绑定导入表有很多这种结构或者_IMAGE_BOUND_FORWARDER_REF这种结构，最后如果有sizeof(_IMAGE_BOUND_IMPORT_DESCRIPTOR)个0，表示绑定导入表结束\t1）TimeDateStamp\n绑定导入表的时间戳：表示程序使用到的DLL中的函数绝对地址真正绑定到IAT表中的时间 作用：系统通过程序使用到的DLL对应的绑定导入表结构中TimeDateStamp和该DLL的标准PE头中的TimeDateStamp对比 如果两个时间戳一样：表明DLL的创建时间和把DLL中的函数绝对地址绑定到IAT表的时间是一样的，则在绑定以后，DLL没有更新或者修改 如果两个时间戳不一样：表明在绑定以后，此DLL又被更新或者修改了，那么绑定到IAT表中的地址可能不准确了！（因为DLL中的函数地址可能变了，但绑定到IAT中的数据可能是以前的函数地址）\n2）OffsetModuleName\n对应DLL的名字：因为一个程序的导入表结构对应一个使用到的DLL；一个程序的绑定导入表结构也对应一个程序使用到的DLL，这个绑定导入表结构记录了该DLL中函数绝对地址绑定到IAT表的时间戳、该DLL的名字、还有该DLL使用到别的DLL的个数\n注意：不管是IMAGE_BOUND_IMPORT_DESCRIPTOR结构中的OffsetModuleName、还是后面要讲的IMAGE_BOUND_FORWARDER_REF 结构中的OffsetModuleName，都必须加上绑定导入表起始RVA值，才是这个结构对应DLL名字的真正RVA\n3）NumberOfModuleForwarderRefs\n因为一个DLL可能还会使用到别的DLL中的函数，所以NumberOfModuleForwarderRefs字段的值是多少，就表明当前绑定导入表对应的DLL还使用了多少个别的DLL，同样表示这个绑定导入表结构后面跟了多少个IMAGE_BOUND_FORWARDER_REF这种结构\nIMAGE_BOUND_FORWARDER_REF结构\n1 2 3 4 5 struct _IMAGE_BOUND_FORWARDER_REF {\tDWORD TimeDateStamp;\t//时间戳\tWORD OffsetModuleName; //对应DLL的名字 WORD Reserved; //保留（未使用）\t} IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF; 打印绑定导入表\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 VOID DisplayBoundImportTable(){ DWORD dwSize = 0; DWORD dwFOA = 0; DWORD dwSizeOfDirectory = 0; LPVOID pFileBuffer = NULL; PIMAGE_DOS_HEADER pDosHeader = NULL; PIMAGE_NT_HEADERS pNTHeader = NULL; PIMAGE_FILE_HEADER pPEHeader = NULL; PIMAGE_DATA_DIRECTORY pDataDirectory = NULL; PIMAGE_BOUND_IMPORT_DESCRIPTOR pBoundImportDescriptor = NULL; PIMAGE_BOUND_FORWARDER_REF pBoundImportRef = NULL; dwSize = ReadPEFile(path, \u0026amp;pFileBuffer); if(dwSize == 0 || !pFileBuffer){ printf(\u0026#34;Fail to read file\\n\u0026#34;); return ; } if(!isPE(pFileBuffer)){ printf(\u0026#34;Is not PE file!\\n\u0026#34;); return ; } pDosHeader = (PIMAGE_DOS_HEADER)pFileBuffer; pNTHeader = (PIMAGE_NT_HEADERS)((BYTE*)pFileBuffer + pDosHeader-\u0026gt;e_lfanew); pPEHeader = \u0026amp;pNTHeader-\u0026gt;FileHeader; if (pNTHeader-\u0026gt;FileHeader.Machine == IMAGE_FILE_MACHINE_AMD64) { PIMAGE_OPTIONAL_HEADER64 pOptionHeader = (PIMAGE_OPTIONAL_HEADER64)\u0026amp;pNTHeader-\u0026gt;OptionalHeader; dwSizeOfDirectory = pOptionHeader-\u0026gt;NumberOfRvaAndSizes; pDataDirectory = pOptionHeader-\u0026gt;DataDirectory; } else { PIMAGE_OPTIONAL_HEADER32 pOptionHeader = (PIMAGE_OPTIONAL_HEADER32)\u0026amp;pNTHeader-\u0026gt;OptionalHeader; dwSizeOfDirectory = pOptionHeader-\u0026gt;NumberOfRvaAndSizes; pDataDirectory = pOptionHeader-\u0026gt;DataDirectory; } dwFOA = RvaToFoa(pFileBuffer, pDataDirectory[11].VirtualAddress);\t//定位绑定导入表 pBoundImportDescriptor = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)((BYTE*)pFileBuffer + dwFOA); auto dwNameBase = (DWORD_PTR)pBoundImportDescriptor; printf(\u0026#34;***************BoundImportDescriptor***************\\n\u0026#34;); while(pBoundImportDescriptor-\u0026gt;OffsetModuleName != 0){ printf(\u0026#34;TimeDateStamp: %x\\n\u0026#34;, pBoundImportDescriptor-\u0026gt;TimeDateStamp); printf(\u0026#34;OffsetModuleName: %s\\n\u0026#34;, (char*)((BYTE*)pFileBuffer + RvaToFoa(pFileBuffer, dwNameBase + pBoundImportDescriptor-\u0026gt;OffsetModuleName))); printf(\u0026#34;NumberOfModuleForwarderRefs: %x\\n\u0026#34;, pBoundImportDescriptor-\u0026gt;NumberOfModuleForwarderRefs); DWORD temp = pBoundImportDescriptor-\u0026gt;NumberOfModuleForwarderRefs; while(temp--){ printf(\u0026#34;--------------Ref--------------\\n\u0026#34;); pBoundImportRef = (PIMAGE_BOUND_FORWARDER_REF)((BYTE*)pBoundImportDescriptor + 8); pBoundImportDescriptor = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)((BYTE*)pBoundImportDescriptor + 8); printf(\u0026#34;\tTimeDateStamp: %x\\n\u0026#34;, pBoundImportDescriptor-\u0026gt;TimeDateStamp); printf(\u0026#34;\tOffsetModuleName: %s\\n\u0026#34;, dwNameBase + pBoundImportDescriptor-\u0026gt;OffsetModuleName); } pBoundImportDescriptor = (PIMAGE_BOUND_IMPORT_DESCRIPTOR)((BYTE*)pBoundImportDescriptor + 8); } free(pFileBuffer); } 导入表注入 导入表注入原理：\n当exe被加载时，系统会根据exe导入表信息来加载需要用到的dll，导入表注入的原理就是修改exe导入表，将自己的dll添加到exe的导入表中，这样exe运行时可以将自己的dll加载到exe的进程空间\n导入表注入的实现步骤：\n1.根据目录项得到导入表信息：VirtualAddress和Size\n2.A：导入表（20B），B：INT表、IAT表（最少8+8B），C：DLL名字符串（dll名称长度+1），D：序号函数名（函数名+1+2B）\n判断哪一个节区空白 \u0026gt; Size（原表大小）+ 20 + A + B + C + D（若空间不够可将C/D存储在其他空白区）\n即空白区 \u0026gt; Size + 0x20\n3.将原导入表Copy到空白区\n4.在新的导入表后面，追加一个空导入表\n5.追加8BINT表、8BIAT表\n6.追加一个IMAGE_IMPORT_BY_NAME结构，前两个字节为0，后面是函数名字符串\n7.将IMAGE_IMPORT_BY_NAME结构的RVA赋值给INT表和IAT表第一项\n8.分配空间存储dll名称字符串，并将该RVA赋值给Name属性\n9.修正IMAGE_DATA_DIRECTORY结构的VirtualAddress和Size\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 #include \u0026lt;windows.h\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #define ALIGN_UP(x, align) (((x) + (align) - 1) \u0026amp; ~((align) - 1)) BOOL InjectImportTable(LPCSTR pszFilePath, LPCSTR pszDllName, LPCSTR pszFuncName) { HANDLE hFile = CreateFileA(pszFilePath, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); if (hFile == INVALID_HANDLE_VALUE) return FALSE; HANDLE hMapping = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL); if (!hMapping) { CloseHandle(hFile); return FALSE; } LPVOID pBase = MapViewOfFile(hMapping, FILE_MAP_WRITE, 0, 0, 0); if (!pBase) { CloseHandle(hMapping); CloseHandle(hFile); return FALSE; } PIMAGE_DOS_HEADER pDosHeader = (PIMAGE_DOS_HEADER)pBase; if (pDosHeader-\u0026gt;e_magic != IMAGE_DOS_SIGNATURE) { UnmapViewOfFile(pBase); CloseHandle(hMapping); CloseHandle(hFile); return FALSE; } PIMAGE_NT_HEADERS pNtHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)pBase + pDosHeader-\u0026gt;e_lfanew); if (pNtHeaders-\u0026gt;Signature != IMAGE_NT_SIGNATURE) { UnmapViewOfFile(pBase); CloseHandle(hMapping); CloseHandle(hFile); return FALSE; } // 获取导入表信息 DWORD importRVA = pNtHeaders-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress; DWORD importSize = pNtHeaders-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size; PIMAGE_SECTION_HEADER pSection = IMAGE_FIRST_SECTION(pNtHeaders); // 查找导入表所在节 PIMAGE_SECTION_HEADER pImportSection = NULL; for (WORD i = 0; i \u0026lt; pNtHeaders-\u0026gt;FileHeader.NumberOfSections; i++) { if (importRVA \u0026gt;= pSection[i].VirtualAddress \u0026amp;\u0026amp; importRVA \u0026lt; pSection[i].VirtualAddress + pSection[i].Misc.VirtualSize) { pImportSection = \u0026amp;pSection[i]; break; } } if (!pImportSection) { UnmapViewOfFile(pBase); CloseHandle(hMapping); CloseHandle(hFile); return FALSE; } // 计算所需空间 DWORD newImportSize = importSize + sizeof(IMAGE_IMPORT_DESCRIPTOR); // 增加新描述符 DWORD dllNameLen = (DWORD)strlen(pszDllName) + 1; DWORD funcNameLen = (DWORD)strlen(pszFuncName) + 1 + sizeof(WORD); // Hint + 函数名 // 计算总需求空间 (描述符+INT+IAT+DLL名+函数名) DWORD totalSpace = newImportSize + 2 * sizeof(DWORD_PTR) * 2 + dllNameLen + funcNameLen; // 寻找空白区域 (从各节末尾查找) PIMAGE_SECTION_HEADER pTargetSection = NULL; DWORD blankOffset = 0; for (WORD i = 0; i \u0026lt; pNtHeaders-\u0026gt;FileHeader.NumberOfSections; i++) { DWORD sectionEnd = pSection[i].PointerToRawData + pSection[i].SizeOfRawData; DWORD blankSize = sectionEnd - (pSection[i].PointerToRawData + pSection[i].Misc.VirtualSize); if (blankSize \u0026gt;= totalSpace) { pTargetSection = \u0026amp;pSection[i]; blankOffset = pSection[i].PointerToRawData + pSection[i].Misc.VirtualSize; break; } } if (!pTargetSection) { // 没有足够空间，使用文件末尾 pTargetSection = \u0026amp;pSection[pNtHeaders-\u0026gt;FileHeader.NumberOfSections - 1]; blankOffset = pTargetSection-\u0026gt;PointerToRawData + pTargetSection-\u0026gt;SizeOfRawData; // 扩展文件大小 DWORD newFileSize = blankOffset + totalSpace; UnmapViewOfFile(pBase); CloseHandle(hMapping); CloseHandle(hFile); // 重新打开文件并设置大小 hFile = CreateFileA(pszFilePath, GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL); SetFilePointer(hFile, newFileSize, NULL, FILE_BEGIN); SetEndOfFile(hFile); // 重新映射 hMapping = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, newFileSize, NULL); pBase = MapViewOfFile(hMapping, FILE_MAP_WRITE, 0, 0, newFileSize); if (!pBase) return FALSE; // 更新指针 pDosHeader = (PIMAGE_DOS_HEADER)pBase; pNtHeaders = (PIMAGE_NT_HEADERS)((DWORD_PTR)pBase + pDosHeader-\u0026gt;e_lfanew); pSection = IMAGE_FIRST_SECTION(pNtHeaders); pTargetSection = \u0026amp;pSection[pNtHeaders-\u0026gt;FileHeader.NumberOfSections - 1]; } // 计算新导入表RVA DWORD newImportRVA = pTargetSection-\u0026gt;VirtualAddress + (blankOffset - pTargetSection-\u0026gt;PointerToRawData); DWORD newImportOffset = blankOffset; // 1. 复制原导入表 DWORD oldImportOffset = importRVA - pImportSection-\u0026gt;VirtualAddress + pImportSection-\u0026gt;PointerToRawData; memcpy((BYTE*)pBase + newImportOffset, (BYTE*)pBase + oldImportOffset, importSize); // 2. 追加新的导入描述符 PIMAGE_IMPORT_DESCRIPTOR pNewImport = (PIMAGE_IMPORT_DESCRIPTOR)((BYTE*)pBase + newImportOffset + importSize); memset(pNewImport, 0, sizeof(IMAGE_IMPORT_DESCRIPTOR)); // 3. 在描述符后追加结束标记 PIMAGE_IMPORT_DESCRIPTOR pEnd = pNewImport + 1; memset(pEnd, 0, sizeof(IMAGE_IMPORT_DESCRIPTOR)); // 4. 计算INT/IAT位置 DWORD thunkOffset = newImportOffset + newImportSize; PDWORD_PTR pINT = (PDWORD_PTR)((BYTE*)pBase + thunkOffset); PDWORD_PTR pIAT = pINT + 2; // INT后紧跟IAT // 5. 设置INT/IAT内容 *pINT = 0; // 初始化为0 *(pINT + 1) = 0; // 结束标记 *pIAT = 0; *(pIAT + 1) = 0; // 6. 写入DLL名称 DWORD dllNameOffset = thunkOffset + 4 * sizeof(DWORD_PTR); // INT(8)+IAT(8)=16字节 strcpy((char*)pBase + dllNameOffset, pszDllName); // 7. 写入函数名结构 DWORD funcNameOffset = dllNameOffset + dllNameLen; *(WORD*)((BYTE*)pBase + funcNameOffset) = 0; // Hint=0 strcpy((char*)pBase + funcNameOffset + sizeof(WORD), pszFuncName); // 8. 设置描述符字段 pNewImport-\u0026gt;OriginalFirstThunk = newImportRVA + importSize; // INT的RVA pNewImport-\u0026gt;Name = newImportRVA + newImportSize; // DLL名称RVA pNewImport-\u0026gt;FirstThunk = newImportRVA + newImportSize + 8; // IAT的RVA (INT后8字节) // 9. 设置函数地址指针 *pINT = newImportRVA + newImportSize + 16; // 函数名结构RVA (INT后16字节) *pIAT = *pINT; // 初始时相同 // 10. 更新数据目录 pNtHeaders-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].VirtualAddress = newImportRVA; pNtHeaders-\u0026gt;OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT].Size = newImportSize; // 11. 更新节属性 pTargetSection-\u0026gt;Characteristics |= IMAGE_SCN_MEM_READ | IMAGE_SCN_MEM_WRITE; pTargetSection-\u0026gt;Misc.VirtualSize = ALIGN_UP(pTargetSection-\u0026gt;Misc.VirtualSize + totalSpace, pNtHeaders-\u0026gt;OptionalHeader.SectionAlignment); // 清理 UnmapViewOfFile(pBase); CloseHandle(hMapping); CloseHandle(hFile); return TRUE; } int main() { if (InjectImportTable(\u0026#34;D:\\\\code\\\\c++\\\\1.exe\u0026#34;, \u0026#34;D:\\\\code\\\\c++\\\\TestDll.dll\u0026#34;, \u0026#34;mySub\u0026#34;)) { printf(\u0026#34;Import table injected successfully!\\n\u0026#34;); } else { printf(\u0026#34;Injection failed!\\n\u0026#34;); } return 0; } 运行上述代码成功，查看一下导入表\n参考\n手写PE结构解析工具\n","date":"2025-07-06T00:00:00Z","image":"https://567liuhuaqing.github.io/p/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/%E6%AF%8D%E7%A5%9E%E5%82%A9_hu_17a824fd97ed2b91.jpg","permalink":"https://567liuhuaqing.github.io/p/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/","title":"PE文件结构"},{"content":"汇编 数据宽度\nBYTE WORD DWORD 8bit 16bit 32bit $$ *寻址范围-\u003e32位or64位* $$\n汇编指令 mov lea add sub 取数据 取地址 加 减 and or xor not \u0026amp; | ^ ! 进阶\n指令格式 功能 ADC R/M,R/M/IMM 带进位加法 SBB R/M,R/M/IMM 带借位减法 XCHG R/M,R/M 交换数据 MOVS B/W/D :[EDI],:[ESI] 移动数据（内存-内存）（[EDI]/[ESI]根据方向标志DF决定自增/减） STOS B/W/D :[EDI] 将AL/AX/EAX的值储存到[EDI]指定的内存单元 REP MOVSD/STOSB/\u0026hellip; 按计数寄存器（ECX）中指定的次数重复执行字符串指令 类型转换 功能 MOVSX CX, AL 符号拓展 MOVZX CX, AL 无符号拓展 内存的读写\nMOV DWORD ptr ds:[0x0012FFC4], 0x12345678\n汇编、寄存器、堆栈窗口大端序；数据窗口小端序\n寻址公式 [立即数] [reg] -\u0026gt; dword ptr ds:[ecx] [reg+立即数] -\u0026gt; dword ptr ds:[ecx+4] [reg+reg*{1, 2, 4, 8}] -\u0026gt; dword ptr ds:[eax+ecx*4] [reg+reg*{1, 2, 4, 8}+立即数] -\u0026gt; dword ptr ds:[eax+ecx*4+4] 标志寄存器 各类标志寄存器 值为1的条件 进位标志CF 运算结果最高位产生一个进位或借位 奇偶标志PF 运算结果中“1”的个数为偶数 辅助进位标志AF 在字/字节操作时，低字节/4位向高字节/4位进位或借位 零标志ZF 运算结果为0 符号标志SF 与运算结果的最高位相同 溢出标志OF 有符号数加减运算是否溢出 常见汇编及JCC 常见汇编 JMP 寄存器/立即数 修改EIP的值 CALL [A]/寄存器 PUSH [B] MOV EIP,[A]/寄存器 RET -\u0026gt; POP EIP CMP R/M,R/M/IMM TEST R/M,R/M/IMM JCC 条件 标志 JE，JZ 结果为零则跳转 ZF=1 JNE，JNZ 结果不为零则跳转 ZF=0 JS 结果为负则跳转 SF=1 JNS 结果为非负则跳转 SF=0 JP，JPE 结果中1的个数为偶数则跳转 PF=1 JNP，JPO 结果中1的个数为奇数则跳转 PF=0 JO 结果溢出了则跳转 OF=1 JNO 结果没有溢出则跳转 OF=0 JB，JNAE 小于则跳转（无符号数） CF=1 JNB，JAE 大于等于则跳转（无符号数） CF=0 JBE，JNA 小于等于则跳转（无符号数） CF=1 or ZF=1 JNBE，JA 大于则跳转（无符号数） CF=0 and ZF=0 JL，JNGE 小于则跳转（有符号数） SF!=OF JNL，JGE 大于等于则跳转（有符号数） SF=OF JLE，JNG 小于等于则跳转（有符号数） ZF=1 or SF!=OF JNLE，JG 大于则跳转（有符号数） ZF=0 and SF=OF 堆栈 push R/M\npop R/M\nesp 栈顶 / ebp 栈底\n无参函数 汇编代码 功能 call 00E71316 调用函数（无参） jmp 00E723D0 00E723D0 push ebp 00E723D1 mov ebp,esp 00E723D3 sub esp,0C0h 提升堆栈 00E723D9 push ebx 00E723DA push esi 00E723DB push edi 保留现场 00E723DC mov edi,ebp 00E723DE xor ecx,ecx 00E723E0 mov eax,0CCCCCCCCh 00E723E5 rep stos dword ptr es:[edi] 00E723E7 mov ecx,0E7E069h 00E723EC call 00E71389 为缓冲区填充数据 00E723F2 pop edi 00E723F3 pop esi 00E723F4 pop ebx 恢复现场 00E723F5 add esp,0C0h 00E723FB cmp ebp,esp 00E723FD call 00E7128F 检查堆栈平衡 00E72402 mov esp,ebp 00E72404 pop ebp 降低堆栈 00E72405 ret 函数返回 有参函数（加法） 汇编代码 功能 000B1D35 push 2 000B1D37 push 1 参数 000B1D39 call 000B143D 调用函数 000B1D3E add esp,8 平衡堆栈 000B143D jmp 000B1CC0 中转 000B1CC0 push ebp 000B1CC1 mov ebp,esp 000B1CC3 sub esp,0C0h 000B1CC9 push ebx 000B1CCA push esi 000B1CCB push edi 000B1CCC mov edi,ebp 000B1CCE xor ecx,ecx 000B1CD0 mov eax,0CCCCCCCCh 000B1CD5 rep stos dword ptr es:[edi] 000B1CD7 mov ecx,0BE069h 000B1CDC call 000B1389 000B1CE1 nop 000B1CE2 mov eax,dword ptr [ebp+8] 000B1CE5 add eax,dword ptr [ebp+0Ch] eax中存储的就是返回值 000B1CE8 pop edi 000B1CE9 pop esi 000B1CEA pop ebx 000B1CEB add esp,0C0h 000B1CF1 cmp ebp,esp 000B1CF3 call 000B128F 000B1CF8 mov esp,ebp 000B1CFA pop ebp 000B1CFB ret 嵌套函数 汇编代码 功能 00761D45 push 3 00761D47 push 2 00761D49 push 1 参数 00761D4B call plus2 (0761442h) 调用函数 00761D50 add esp,0Ch 平衡堆栈 00761442 jmp plus2 (0762490h) 中转 00762490 push ebp 00762491 mov ebp,esp 00762493 sub esp,0CCh 00762499 push ebx 0076249A push esi 0076249B push edi 0076249C lea edi,[ebp-0Ch] 0076249F mov ecx,3 007624A4 mov eax,0CCCCCCCCh 007624A9 rep stos dword ptr es:[edi] 007624AB mov ecx,76E069h 007624B0 call 00761389 007624B5 nop 12: int t = plus1(a, b);007624B6 mov eax,dword ptr [ebp+0Ch] eax=2 007624B9 push eax 2入栈（参数） 007624BA mov ecx,dword ptr [ebp+8] ecx=1 007624BD push ecx 1入栈（参数） 007624BE call plus1 (076143Dh) 函数调用 007624C3 add esp,8 平衡堆栈 007624C6 mov dword ptr [ebp-8],eax eax是plus1返回结果，ebp-8是局部变量t 13: return plus1(t, c);007624C9 mov eax,dword ptr [ebp+10h] 007624CC push eax 007624CD mov ecx,dword ptr [ebp-8] 007624D0 push ecx 007624D1 call 0076143D 007624D6 add esp,8 同上 0076143D jmp plus1 (00761CC0h) 00761CC0 push ebp 00761CC1 mov ebp,esp 00761CC3 sub esp,0C0h 00761CC9 push ebx 00761CCA push esi 00761CCB push edi 00761CCC mov edi,ebp 00761CCE xor ecx,ecx 00761CD0 mov eax,0CCCCCCCCh 00761CD5 rep stos dword ptr es:[edi] 00761CD7 mov ecx,76E069h 00761CDC call 00761389 00761CE1 nop 9: return a + b;00761CE2 mov eax,dword ptr [ebp+8] 00761CE5 add eax,dword ptr [ebp+0Ch] 00761CE8 pop edi 00761CE9 pop esi 00761CEA pop ebx 00761CEB add esp,0C0h 00761CF1 cmp ebp,esp 00761CF3 call 0076128F 00761CF8 mov esp,ebp 00761CFA pop ebp 00761CFB ret plus1(t, c) 007624D9 pop edi 007624DA pop esi 007624DB pop ebx 007624DC add esp,0CCh 007624E2 cmp ebp,esp 007624E4 call 0076128F 007624E9 mov esp,ebp 007624EB pop ebp 007624EC ret 裸函数及其调用约定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void __declspec(naked) plus(/*int x, int y, int z*/) { //裸函数 __asm { /* push ebp; //提升堆栈 mov ebp, esp; sub esp, 0x40; push ebx; //保留现场 push esi; push edi; mov eax, 0xCCCCCCCC; //填充缓冲区 mov ecx, 0x10; lea edi, dword ptr ds : [ebp - 0x40] ; rep stosd; mov eax, dword ptr ds : [ebp + 8] ; //函数功能\tx add eax, dword ptr ds : [ebp + 0xC] ;\t//y add eax, dword ptr ds : [ebp + 0x10] ;\t//z //__emit 0xe8; pop edi; //恢复现场 pop esi; pop edx; mov esp, ebp; //降低堆栈 pop ebp; */ ret; } } 调用约定 参数压栈顺序 平衡堆栈 __cdecl 从右至左入栈 调用者清理栈 __stdcall 从右至左入栈 自身清理堆栈-\u0026gt;ret 8 __fastcall ecx/edx传送前两个\n剩下：从右至左入栈 自身清理堆栈 内存图\nif，else，while 代码区 参数，局部变量，临时数据 堆栈 动态申请的，大小可变的\n可读，可写 堆 可读，可写 全局变量区 只读 常量区 位运算\n算数移位 指令格式 逻辑移位 指令格式 溢出位进CF SAL/SAR R/M,CL/I 溢出位进CF SHL/SHR R/M,CL/I 算数左移 SAL（补0） 逻辑左移 SHL（补0） 算数右移 SAR（补符号位） 逻辑右移 SHR（补0） 循环移位 指令格式 带进位循环 指令格式 溢出位进CF ROL R/M, I\nROR R/M, CL 溢出位进CF RCL R/M, I\nRCR R/M, CL 循环左移 ROL（补溢出位） 左移 RCL（补CF位） 循环右移 ROR（补溢出位） 右移 RCR（补CF位） ","date":"2025-05-12T00:00:00Z","image":"https://567liuhuaqing.github.io/p/%E6%B1%87%E7%BC%96/%E8%9C%98%E8%9B%9B_hu_f17d66f841bed753.jpg","permalink":"https://567liuhuaqing.github.io/p/%E6%B1%87%E7%BC%96/","title":"汇编"},{"content":"简介 自修改代码（Self-Modified Code）是一类特殊的代码加密技术，即在运行时修改自身代码或数据，从而使得程序实际行为与反汇编结果不符，同时修改前的代码段数据也可能非合法指令，从而无法被反汇编器识别，这加大了软件逆向工程的难度\n基本原理：是在编译可执行文件时，将需要加密的代码区段（如函数、代码块） 单独编译成一个section（段），并将其标记为可读，可写，不可执行，然后通过某种方法在程序运行的时候将section解密为可执行代码，并将其标记为可读、可执行、不可写，这样就不能直接在内存里面找到加密的代码，从而无法执行或修改加密的代码\nSMC的实现方式有很多种，可以通过修改PE文件的Section Header、使用API Hook实现代码加密和解密、使用VMProtect等第三方加密工具等\nSMC两种破解方式，第一种是根据静态分析结果直接修改程序二进制文件，第二种则是在动态调试时将解密后的程序从内存中 dump 下来\n编写SMC程序 一般smc程序的执行流程（假设关键函数为func）\nmain函数中获取func函数的地址 取消func函数处的页面保护 对func进行解密操作之后再调用func 为了编写smc程序，我们需要进行如下操作\n先写好func函数和main函数中的解密代码（此时不能真正解密,还需要矫正） 编译后用ida打开exe程序，找到func地址及大小，从而修正主函数的参数 用ida对func函数进行patch，保存patch后的程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;Windows.h\u0026gt; int func(int x, int y) { unsigned int z = 0x12345678; x = y ^ z; y = x ^ z; char flag[] = \u0026#34;helloworld\u0026#34;; printf(\u0026#34;%s\u0026#34;, flag); return x ^ y ^ z; } int main() { DWORD64 old; byte* pfunc = (byte*)func;//函数地址 VirtualProtect(func,0xE1, PAGE_EXECUTE_READWRITE, \u0026amp;old);//第二个参数为大小,可以编译后通过ida查看得到 pfunc = pfunc + *(DWORD*)(pfunc+1) + 5;//加上偏移值才是真实func地址+5是由于e9 jmp指令后的四字节是相对偏移 for (int i = 0; i \u0026lt; 0xE1; i++)//解密操作 也需要修正大小 这里是修正后的 pfunc[i] ^= 0x12; func(5, 6); return 0; } 如果直接运行该程序肯定会出错，因为此时相当于对func函数加密而非解密，所以需要用ida进行patch，idapython脚本进行patch\n1 2 3 4 5 6 7 import idc import ida_bytes addr=0x140011890 for i in range(0xe1): tmp=idc.get_wide_byte(addr) ida_bytes.patch_byte(addr,tmp^0x12) addr=addr+1 记得保存patch后的程序，再用ida打开patch后的程序，在解密func函数可用脚本解密或下断点动调观察\n测试patch后的程序 解密前的func函数，无法正常识别\n解密后的func，ida重新识别可反编译\n参考 smc动态加密技术\n风信子培训smc\n","date":"2025-03-12T22:35:59+08:00","image":"https://567liuhuaqing.github.io/p/smc%E8%87%AA%E4%BF%AE%E6%94%B9/%E5%89%AA%E5%88%80_hu_693e7fae84ce8950.jpg","permalink":"https://567liuhuaqing.github.io/p/smc%E8%87%AA%E4%BF%AE%E6%94%B9/","title":"SMC自修改"},{"content":"简介 花指令（junk code）是一种专门用来迷惑反编译器的指令片段，这些指令片段不会影响程序的原有功能，但会使得反汇编器的结果出现偏差，从而使破解者分析失败。比较经典的花指令技巧有利用 jmp 、call、ret 指令改变执行流，从而使得反汇编器解析出与运行时不相符的错误代码\n铺垫 反汇编算法 线性扫描 从程序入口点开始遍历一整个代码端，逐行对命令进行反汇编\n缺点：在冯诺依曼体系结构下，无法区分数据与代码，从而导致将数据解释为指令操作码\n递归下降 从程序入口点开始读取机器码进行反汇编，通过程序控制流来确定汇编的下一条指令，遇到无条件跳转直接跳转，遇到条件跳转则从两个命令执行分支处进行解析（优先解析顺序执行分支）\n常用花指令硬编码 硬编码：汇编指令对应的机器码，通常以16进制表示\n1 2 3 4 5 6 7 8 9 10 11 addr: 汇编指令跳转的目标地址 immedn: 目的地址与当前指令下一条指令地址的距离, 是一个偏移值 nop ----\u0026gt; 90 //1字节指令,空指令 call addr ----\u0026gt; E8 immed32 //5字节指令，immed32为4字节 call far ptr addr ----\u0026gt; 9A immed48 //7字节指令，immed48为6字节 jmp short near ptr addr ----\u0026gt; EB immed8 //2字节指令,immed8为1字节 jmp near ptr addr ----\u0026gt; E9 immed32 //5字节指令 jmp far ptr addr ----\u0026gt; EA immed48 //7字节指令 loop near ptr addr ----\u0026gt; E2 immed8 //2字节指令 ret ----\u0026gt; C2 n16 //3字节指令 等价于pop n和pop eip retn ----\u0026gt; C3 //1字节指令 等价于pop eip 两大分类 可执行花指令 可执行花指令指的是花指令代码在程序的正常执行过程中会被执行，但执行这些代码没有任何意义，执行前后不改变任何寄存器的值，同时这部分代码也会被反汇编器正常识别，其目的依然是加大静态分析的难度，让你难以识别代码的真正意图，有时这种花指令可以破坏反编译的分析，使得栈指针在反编译引擎中出现异常\n压栈后恢复栈地址 1 2 3 4 _asm { push eax; add esp, 4; } call\u0026amp;ret构造 1 2 3 4 5 6 7 8 9 10 _asm { call label label: add dword ptr ss : [esp], 7;//注意变长指令 ret } real_code //特点: 可执行花指令,最终会跳转至real_code标签处执行 //call指令本质是push nextcode和jmp desAddr，ret指令本质是jmp [esp]和sub esp,4 //在ret和real_code中间可以任意插入花指令，但要根据插入字节数添加对应add值 所以也可以通过push和jmp配合实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 _asm { push eax push ecx jmp label_1 label_2: mov eax,[esp] add [esp],8 jmp eax label_1: call label_2 pop eax } printf(\u0026#34;Hello world!\\n\u0026#34;); 通过压栈、退栈和跳转混淆代码，IDA将退栈指令识别为破坏堆栈平衡而报错，识别这类花指令后，将跳转和无效压栈等操作指令全部NOP掉即可\n混淆特征码 如下一些指令功能可以用替代指令完成，目的即增加反汇编分析的复杂程度：\n1 2 3 4 mov op1,op2 ----\u0026gt; push op2 / pop op1 jmp label ----\u0026gt; push label / ret call label ----\u0026gt; push label_next_instruction / push label / ret push op ----\u0026gt; sub esp,4 / mov [esp],op 永真条件跳转 可见后文\n不可执行花指令 不可执行花指令就是在程序执行过程中不会被执行，但利用静态分析算法的缺陷使反汇编分析执行会出错的垃圾数据，就会导致解析错误，这时我们需要跳过这些花指令才能保证程序正常运行\n简单e8跳转 简单的花指令0xe8是跳转指令，可以对线性扫描算法进行干扰，但是递归扫描算法可以正常分析\n1 2 3 4 5 _asm { jmp label1 _emit 0xe8 label1: } OD还是能被骗过去，但是因为ida采用的是递归扫描的办法所以能够正常识别\njz和jnz条件跳转 利用jz和jnz的互补条件跳转指令来代替jmp，两个跳转一个指向无效数据，一个指向正常数据来干扰递归扫描算法即ida不能正常识别\n1 2 3 4 5 6 7 8 _asm { jz lable2 jnz lable2 _emit 0xe8 lable2: } //特点: 不可执行花指令，无论是jz还是jnz指令，最终都跳转至label //在jnz label和label之间可以插入任意花指令 将这类花指令NOP即可，也可以将条件跳转指令换成无条件跳转jmp，此时ida反编译就不会报错，原理可分析递归下降算法\n永真条件跳转 通过设置永真或者永假的，导致程序一定会执行，由于ida反汇编会优先反汇编接下去的部分（false分支），也可以调用某些函数会返回确定值，来达到构造永真或永假条件\n1 2 3 4 5 6 7 8 9 10 11 12 13 _asm{ push ebx xor ebx,ebx test ebx,ebx jnz label1 jz label2 label1: _emit junkcode label2: pop ebx //需要恢复ebx寄存器 } //特点: 可执行花指令,有2条跳转分支,但只有一条分支为永真会被执行,另一条永假不执行 //在虚假分支处可以插入任意花指令 破坏堆栈平衡 汇编中函数如果有参数或局部变量，在调用前会对堆栈进行保护 ，在返回前要还原函数调用前的堆栈，这一过程程序在编译时会自动加上，如果反编译器检测到指令破坏了堆栈平衡，即函数返回时与调用时堆栈状态发生了变化，就会报错，可以利用这一点构造破坏堆栈平衡的花指令\n1 2 3 4 5 6 7 8 _asm { test eax,0 // 构造必然条件实现跳转，绕过破坏堆栈平衡的指令 jz label add esp,0x1 label: } printf(\u0026#34;Hello World!\\n\u0026#34;); //不可执行花指令 这类破环堆栈平衡的指令实际不会执行，但是由于IDA在反汇编分析时会分别从两个条件跳转处开始分析，因此判定堆栈不平衡导致反汇编失败，解决方法是NOP掉破坏堆栈平衡的指令\n参考 花指令总结\n逆向基础花指令\n恶意代码分析\n","date":"2025-03-12T15:19:48+08:00","image":"https://567liuhuaqing.github.io/p/%E8%8A%B1%E6%8C%87%E4%BB%A4%E6%94%BB%E5%85%8B/%E8%9D%B4%E8%9D%B6_hu_610be22edafe865e.jpg","permalink":"https://567liuhuaqing.github.io/p/%E8%8A%B1%E6%8C%87%E4%BB%A4%E6%94%BB%E5%85%8B/","title":"花指令攻克"},{"content":"目录\n[ 工具附件](# 工具附件)\n.py文件和.pyc文件\n[ 提取.pyc文件](# 提取.pyc文件)\npycdc反编译 pycdas查看字节码\n举个例子\n工具附件 DIE查壳工具 根据自己电脑选择win64位\n编辑\n链接：python逆向附件 提取码：1013\n.py文件和.pyc文件 ​ 首先，我们来认识一下.py文件和.pyc文件 ​ .py文件是python的源代码文件，也就是你写的源代码存放的地方。机器是无法直接读懂你写的源代码的，于是当你运行一个 Python 程序时，Python 解释器会将源代码编译成一种称为字节码的中间形式，然后将字节码存储在.pyc文件里面，当你下次再运行同样的程序时，机器会直接找到之前生成的.pyc文件进行加载。 ​ .pyc文件，是源代码经过编译后的一种中间表示形式。它无法双击直接运行，并且需要依赖特定的python环境（一个版本的python生成的pyc文件可能其他版本不能使用）所以它并不是可执行文件。它的存在仅仅是为了加快程序执行效率，避免重复编译。 这样就引来了一个问题——它不能像C一样自动生成一个可执行文件，如若要使用，则必须下载python环境并运行源代码，这样做非常依赖环境。 ​ 于是python提供了PyInstaller这个库，它可以将.py文件转为.exe文件，这样产生的.exe文件在没有Python环境时也可以直接使用。 ​ 一般的.py转成的.exe文件长这样:\n编辑\n我们可以用DIE打开看到为python语言写的\n编辑\n提取.pyc文件 ​ 第一步，将.exe转化成.pyc文件 ​ 使用工具pyinstxtractor.py提取.pyc文件 ​ 使用方法：在该pyinstxtractor.py文件所在目录打开终端，输入\n1 python pyinstxtractor.py [文件完整路径] ​ 这条指令的意思是用python解释器运行pyinstxtractor.py脚本，并把这个.exe文件作为参数传入。 ​ 输入完成后文件目录下会出现一个文件名_extracted文件夹\n编辑\n​ 打开这个文件夹，找到里面与.exe文件同名的.pyc文件\n编辑\npycdc反编译 ​ 上一步得到.pyc文件后，我们需要使用工具来查看源代码。 ​ 这里有两种方法，第一种是用pycdc反编译：将.pyc文件与pycdc放于同一个目录，打开终端，输入\n1 pycdas(.exe) [文件名] #括号内的部分可省略 ​ 这个指令就是把文件当参数传入，然后运行pycdc.exe，它就会把字节码反编译为源码。 ​ 但这个工具有时候不能反编译出所有的代码，这时我们就要用到另一种工具：pycdas\npycdas查看字节码 ​ 当pycdc反编译不完全时，就需要使用pycdas。 ​ .pyc文件是二进制文件，无法直接打开查看内容，而pycdas则可以帮助我们查看.pyc文件里面的字节码。 ​ 使用方法与pycdc相同：将.pyc文件与pycdas放于同一目录，然后打开终端，输入\n1 pycdas(.exe) [文件名] #括号内的部分可省略 有时python版本太高，反编译不出python源码\n使用python解释器调用dis解释出pyc文件的字节码\n1 2 3 4 5 6 7 import marshal import dis f=open(r\u0026#39;easyRE.pyc\u0026#39;,\u0026#39;rb\u0026#39;) # 将pyc文件和该脚本放于同一文件夹内,或者自行指定绝对路径 code=marshal.loads(f.read()[16:]) print(dis.dis(code)) f.close() ​ 相应工具以上传至文章顶部\n举个例子 将题目附件拖进DIE查壳，可发现为python可执行文件\n编辑\n在pyinstxtractor.py文件所在目录打开终端，输入\n1 python pyinstxtractor.py [文件完整路径] 提取.pyc文件，出现以下界面\n编辑\n在文件目录下出现test.exe_extracted文件夹\n编辑\n在这个文件夹里面找到与.exe文件同名的.pyc文件\n编辑\n将改.pyc文件与pycdc放于同一个目录，打开终端，输入\n1 pycdc test.exe 可以看到python源码\n编辑\n易知为base64解密，可以写脚本，也可以用工具\n编辑\n得到flag{Reverse_python}\n备注例题也以上传\n","date":"2025-02-27T22:50:04+08:00","permalink":"https://567liuhuaqing.github.io/p/python_rev/","title":"Python_Rev"},{"content":"HelloBlog ","date":"2025-02-27T10:55:18+08:00","image":"https://567liuhuaqing.github.io/p/myfisrtblog/%E5%BA%93%E6%B4%9B%E7%B1%B3%E5%A0%86%E7%B3%96_hu_3fd1b0f24221433e.jpg","permalink":"https://567liuhuaqing.github.io/p/myfisrtblog/","title":"MyFisrtBlog"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://567liuhuaqing.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://567liuhuaqing.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://567liuhuaqing.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://567liuhuaqing.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://567liuhuaqing.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://567liuhuaqing.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://567liuhuaqing.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://567liuhuaqing.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://567liuhuaqing.github.io/p/emoji-support/","title":"Emoji Support"},{"content":" Win32 是 Microsoft Windows 操作系统的核心应用程序编程接口（API），用于开发在 Windows 平台上运行的应用程序\nWin32 编码 Win32 字符编码体系\n编码类型 宽字符 (Unicode) 多字节字符 (ANSI) 字符大小 2字节（wchar_t） 1字节（char） 编码标准 UTF-16（小端序） 本地代码页（如GBK, Shift-JIS） API 后缀 W（如 MessageBoxW） A（如 MessageBoxA） 前缀标识 L（如 L\u0026quot;文本\u0026quot;） 无（如 \u0026quot;文本\u0026quot;） 适用场景 现代 Windows 应用（Win2000+） 兼容旧系统（Win9x） 推荐指数 ★★★★★（微软官方推荐） ★☆☆☆☆（已淘汰） 历史演进与技术替代\n技术 出现时间 字符编码 现状 Win16 API 1985 ANSI 完全淘汰 Win32 API (A) 1993 ANSI 遗留系统维护 Win32 API (W) 2000 UTF-16 主流使用 WinRT/UWP 2012 UTF-16 (兼容UTF-8) 新一代应用 宽字符 Unicode Unicode编码创建了一张包含世界上所有文字的编码表，只要世界上存在的文字符号，都会赋予一个唯一的编码。\nUnicode编码的范围是：0x0-0x10FFFF，其可以容纳100多万个符号，但是Unicode本身也存在问题，因为Unicode只是一个符号集，它只规定了符号的二进制代码，却没有规定这个二进制代码应该如何去存储。\nUnicode存储的实现方式 UTF-8, UTF-16, UTF-32：它们就是将 Unicode 码点转换成计算机字节序列的具体规则。同一个 Unicode 码点，用这三种编码方式存储，得到的字节序列是不同的。 特性 UTF-8 UTF-16 UTF-32 编码单元 1 字节 (8位) 2 字节 (16位) 4 字节 (32位) 长度 变长 (1-4字节) 变长 (2或4字节) 定长 (4字节) BOM标记 可选 (EF BB BF) 必需 (FE FF 或 FF FE) 可选 (00 00 FE FF) 对ASCII的兼容性 完全兼容 不兼容 不兼容 空间效率 对西文最高，对东亚文中等 对东亚文最高，对西文中等 最低，非常浪费空间 处理效率 长度不固定，计算字符数和索引较慢 多数常用字符定长，处理较快 定长，计算字符数和索引最快 字节序(Endianness)问题 无 有 (需BOM区分) 有 (需BOM区分) 应用场景 互联网、Web、操作系统文件系统 Windows内部、Java、.NET 学术研究、内存中临时处理 UTF-8 (8-bit Unicode Transformation Format) 这是目前互联网上使用最广泛的Unicode编码方式。\n核心思想： 用“前缀位”来表示一个字符需要用几个字节。 规则： 单字节：0xxxxxxx。用于表示所有 ASCII 字符 (U+0000 到 U+007F)。这也是它完美兼容ASCII的原因。 双字节：110xxxxx 10xxxxxx。用于表示一些拉丁文、希腊文等。 三字节：1110xxxx 10xxxxxx 10xxxxxx。用于表示绝大多数常用汉字等中日韩字符。 四字节：11110xxx 10xxxxxx 10xxxxxx 10xxxxxx。用于表示不常用的字符和Emoji表情等。 UTF-16 (16-bit Unicode Transformation Format) 在很多系统内部，尤其是 Windows 和 Java，这是首选的编码方式。\n核心思想： 尽量用2个字节表示一个字符，实在不行再用4个。 规则： 对于码点在 U+0000 到 U+FFFF 之间的字符（这个范围包含了几乎所有常用字符，包括大部分汉字），直接用2个字节存储。 对于码点超出 U+FFFF 的字符（如Emoji），使用代理对 (Surrogate Pair) 的方式，用4个字节来表示。 UTF-32 (32-bit Unicode Transformation Format) 最简单直接，但也最浪费空间的编码方式。\n核心思想： 不管什么字符，一律用4个字节（32位）来表示。 规则： 直接将Unicode码点的值用4个字节存储。 C语言中的宽字符 1.宽字符使用\n“中”字编码：\nASCII：d6 d0\nUNICODE（UTF-16）：4e 2d\n数据类型 宽字符版本 多字节版本 字符类型 wchar_t char 字符串指针 LPCWSTR (const wchar_t*) LPCSTR (const char*) 可变字符串 LPWSTR (wchar_t*) LPSTR (char*) 通用字符类型 TCHAR（根据配置变化） 通用字符串宏 LPTSTR, LPCTSTR 字符和字符串\n1 2 3 4 5 char x = \u0026#39;中\u0026#39;;\t//使用拓展ASCII编码 wchar_t x1 = L\u0026#39;中\u0026#39;;\t//L指宽字符Unicode编码 char x[] = \u0026#34;中国\u0026#34;; //A wchar_t x1[] = L\u0026#34;中国\u0026#34;; //W 2.打印宽字符\n包含头文件#include \u0026lt;locale.h\u0026gt;\n主函数中添加\n1 2 3 setlocale(LC_ALL, \u0026#34;\u0026#34;);\t//默认本地操作系统地域 printf(\u0026#34;%s\\n\u0026#34;, x);\t//使用控制台默认编码 wprintf(L\u0026#34;%s\\n\u0026#34;, x1);\t//默认使用英文，可通过setlocale修改地域 3.字符串长度\n头文件#include \u0026lt;string.h\u0026gt;\n1 2 strlen(x);\t//取得多字符编码字符串长度 wcslen(x1);\t//取得宽字符编码字符串长度 4.字符串操作\n1 2 3 4 5 6 char x[] = \u0026#34;china\u0026#34;; char x1[] = \u0026#34;123\u0026#34;; strcpy(x, x1); wchar_t y[] = L\u0026#34;中国\u0026#34;; wchar_t y1[] = L\u0026#34;好\u0026#34;; wcscpy(y, y1); 还有wcscat、wcscmp、wcsstr等\nWin32 API API（Application Programming Interface，应用程序编程接口）\n什么是Win32 API Win32 API 是 Windows 操作系统底层的应用程序编程接口，为开发者提供直接访问操作系统核心功能的途径，其主要存放在C:\\Windows\\System32（存储的DLL是64位）、C:\\Windows\\SysWOW64（存储的DLL是32位）下面的所有DLL文件（几千个）\n特性 说明 接口类型 过程化 C 语言 API（非面向对象） 架构层级 用户模式与内核模式间的桥梁 实现方式 通过 DLL 文件暴露函数（如 kernel32.dll, user32.dll） 历史地位 Windows 95 至今的核心 API（Win64 是其在 64 位系统的扩展） 不可替代性 所有 Windows 应用框架（.NET/WinUI）最终都调用 Win32 API 关键功能DLL 通过这些dll（三环）调用内核函数\n系统服务（Kernel32.dll） 进程/线程：CreateProcess(), CreateThread() 内存管理：VirtualAlloc(), HeapAlloc() 文件操作：CreateFile(), ReadFile() 同步对象：CreateMutex(), WaitForSingleObject() 用户界面（User32.dll） 窗口管理：CreateWindowEx(), ShowWindow() 消息循环：GetMessage(), DispatchMessage() 控件操作：CreateButton(), SetWindowText() 资源管理：LoadIcon(), LoadString() 图形设备（GDI32.dll） 绘图：LineTo(), Rectangle() 文本：TextOut(), DrawText() 位图：CreateBitmap(), BitBlt() 设备上下文：GetDC(), ReleaseDC() 高级服务 注册表：RegOpenKeyEx(), RegSetValueEx()（Advapi32.dll） 网络：WSAStartup(), socket()（Ws2_32.dll） COM 组件：CoInitialize(), CoCreateInstance()（Ole32.dll） 安全：CryptAcquireContext(), CryptEncrypt()（Crypt32.dll） Win32 API编码 Windows是使用C语言开发的，Win32 API同时支持宽字符和多字节字符\nWindows下所有内核函数，涉及字符串均使用宽字节\nWindows提供的类型如下：（包含头文件Window.h）\n1.字符类型\n1 2 3 4 5 6 7 8 C\t-- Win32 char -- CHAR\t//F12可跟进查看类型 wchar_t -- WCHAR 宏 -- TCHAR\t//若当前项目设置为ASCII编码，则相当于CHAR；若为Unicode编码，则相当于WCHAR，在Win32中推荐使用 //用法 CHAR cha[] = \u0026#34;中国\u0026#34;; WCHAR chw[] = L\u0026#34;中国\u0026#34;; TCHAR cht[] = TEXT(\u0026#34;中国\u0026#34;); 2.字符串指针\n1 2 3 4 5 6 7 PSTR(LPSTR)\t//指向多字节字符串 PWSTR(LPWSTR)\t//指向宽字符串 宏 -- PTSTR(LPTSTR) //用法 PSTR pszC = \u0026#34;China\u0026#34;; PWSTR pszWC = L\u0026#34;china\u0026#34;; PTSTR pszTC = TEXT(\u0026#34;china\u0026#34;); Windows提供的API，若需要传递字符串参数，都会提供两个版本和一个宏，如：\n1 2 3 MessageBoxA(0, \u0026#34;多字节\u0026#34;, \u0026#34;标题\u0026#34;, MB_OK); MessageBoxW(0, L\u0026#34;宽字符\u0026#34;, L\u0026#34;标题\u0026#34;, MB_OK); MessageBox(0, TEXT(\u0026#34;内容\u0026#34;), TEXT(\u0026#34;标题\u0026#34;), MB_OK); 从本质上来讲，Windows字符串都是宽字符的，所以使用MessageBoxW这种方式性能会更好一些，因为当你使用MessageBoxA的时候，在到内核的时候（系统底层）其会转化Unicode，弹窗调用如下：\n1 2 3 WCHAR strTitle[] = L\u0026#34;Title\u0026#34;; WCHAR strContent[] = L\u0026#34;Hello World!\u0026#34;; MessageBoxW(0, strContent, strTitle, MB_OK); Win32入口程序 VS创建项目Windows桌面应用程序\nwWinMain 是 Windows 图形用户界面（GUI）应用程序的入口点，它相当于 C/C++ 控制台程序中的 main 函数\n当你在 Windows 系统上双击一个 .exe 文件的图标时，操作系统加载完程序后，第一个调用的就是这个函数（或者它的非宽字符版本 WinMain），函数签名\n1 2 3 4 5 6 int APIENTRY wWinMain( _In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow ) APIENTRY: 这是一个宏，通常被定义为 __stdcall，这是所有标准 Win32 API 函数使用的约定，所以你的入口点也必须遵守 wWinMain:“Windows Main Function” 前缀 w 代表 Wide-character（宽字符），这意味着这个版本的入口点接收的是**宽字符（UTF-16）**格式的命令行参数。与之对应的是 WinMain（没有w），它接收的是 ANSI（多字节）字符 HINSTANCE: Handle to an Instance（实例句柄） 句柄 (Handle)：在Windows中，句柄是一个唯一的数字，它代表了操作系统管理的某个资源（如窗口、文件、进程等） 实例句柄 (Instance Handle)：hInstance 是一个指向你程序被加载到内存中的那个模块 (module) 的句柄，通常，一个 .exe 文件就是一个模块。这个句柄非常重要，因为操作系统用它来唯一标识你的应用程序实例。 用途：你会在很多后续的 Win32 API 调用中用到它，比如加载图标、光标、字符串资源，或者创建窗口时告诉系统这个窗口属于哪个程序实例。 HINSTANCE hPrevInstance: Handle to a Previous Instance（前一个实例的句柄）。 历史遗留物：在古老的16位Windows时代，这个参数用来判断是否已经有同一个程序的实例在运行。如果有，hPrevInstance 会是一个有效值。 在现代32位和64位Windows中，这个参数永远是 NULL (0)。因为现代操作系统为每个程序提供了独立的地址空间，一个程序无法轻易地知道另一个实例的存在。如果你需要实现“单实例”应用程序（即只允许程序运行一个），你需要使用其他更现代的方法，比如互斥体 (Mutex)。 结论：你可以完全忽略这个参数。 lpCmdLine: 这个参数包含了传递给程序的命令行参数 例如，如果你在命令行中运行 my_program.exe /config \u0026quot;settings.xml\u0026quot; -debug，那么 lpCmdLine 指向的字符串就是 \u0026quot;/config \\\u0026quot;settings.xml\\\u0026quot; -debug\u0026quot;。 注意：它不包含程序本身的名称。如果你需要获取程序自己的路径，应该使用 GetModuleFileName 函数。 int nCmdShow: 这个参数是一个整数，指定了程序的主窗口应该以何种状态显示 这个值是由启动你的程序的那个进程（比如 Windows 资源管理器）传递过来的。 常见的值： SW_SHOWNORMAL: 正常显示窗口（不最大化也不最小化）。 SW_SHOWMAXIMIZED: 最大化显示。 SW_SHOWMINIMIZED: 最小化到任务栏。 如何使用：在你创建完主窗口后，你应该将这个 nCmdShow 值传递给 ShowWindow 函数，作为它的第二个参数。这是为了尊重启动者的意图。例如，如果用户在另一个程序的快捷方式属性里设置了“以最大化方式运行”，那么操作系统就会通过 nCmdShow 告诉你应该这么做。 wWinMain 的典型结构\n一个经典的 wWinMain 函数内部通常会做以下几件事：\n注册窗口类 (Register Window Class)：使用 WNDCLASSEX 结构体定义窗口的各种属性（如窗口过程函数、图标、光标、背景颜色等），然后调用 RegisterClassEx 告诉操作系统“我要创建一种这样的窗口”。 创建窗口 (Create Window)：调用 CreateWindowEx 函数，使用上一步注册的窗口类来创建一个具体的窗口实例。 显示和更新窗口 (Show and Update Window)：调用 ShowWindow（并传入 nCmdShow）和 UpdateWindow，让窗口显示在屏幕上并绘制其内容。 进入消息循环 (Message Loop)： 这是一个 while 循环，不断调用 GetMessage 从程序的消息队列中获取消息（如鼠标点击、键盘按键、窗口重绘请求等）。 调用 TranslateMessage 进行一些键盘消息的转换。 调用 DispatchMessage 将消息分发给对应的窗口过程函数（WndProc）去处理。 循环结束，返回：当 GetMessage 收到 WM_QUIT 消息时，它会返回 FALSE，循环结束，wWinMain 函数返回，程序退出。 Win32程序中调试信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include \u0026lt;windows.h\u0026gt; // 使用 OutputDebugString 输出调试信息 void PrintDebugMessage(LPCWSTR message) { OutputDebugString(message); // 在调试器输出窗口显示 // OutputDebugString(L\u0026#34;Debug message\\n\u0026#34;); // 示例 } // 带格式化输出 void PrintDebugFormat(LPCWSTR format, ...) { wchar_t buffer[256]; va_list args; va_start(args, format); vswprintf_s(buffer, 256, format, args); va_end(args); OutputDebugString(buffer); } // 使用示例： PrintDebugFormat(L\u0026#34;鼠标位置: X=%d, Y=%d\\n\u0026#34;, xPos, yPos); GetLastError的使用 1 2 MessageBox((HWND)1, 0, 0, 0); DWORD erro = GetLastError();\t//将改代码放在错误语句的后面，在其后设置断点，F5运行到断点，鼠标放在erro上查看错误值 VS提供错误查找工具\n输入刚刚的错误值查看错误信息\nWin32图形界面 事件与消息 在 Windows 中，事件 (Event Object) 是一种内核对象 (Kernel Object)，它与进程、线程、互斥体 (Mutex)、信号量 (Semaphore) 处于同一层面\n事件特征：\n用途：主要用于线程间的同步（Synchronization）。一个线程可以等待一个事件，而另一个线程可以触发这个事件，从而唤醒等待的线程。 状态：事件只有两种状态——已触发 (Signaled) 和 未触发 (Non-signaled)。 类型： 手动重置事件 (Manual-reset Event)：一旦被触发，它会一直保持“已触发”状态，直到有代码明确地调用 ResetEvent 函数将其重置为“未触发”。它可以同时唤醒所有正在等待它的线程。 自动重置事件 (Auto-reset Event)：一旦被触发并成功唤醒一个等待的线程后，它会自动变回“未触发”状态。就像一个只能一个人通过的旋转门。 操作函数：CreateEvent, SetEvent (触发), ResetEvent (重置), WaitForSingleObject, WaitForMultipleObjects (等待)。 可见性：可以是匿名的（只在当前进程内可见），也可以是命名的（可以跨进程共享和访问） 在 Windows 中，消息 (Message) 是 GUI 子系统（USER32） 用来与应用程序窗口进行通信的数据结构，它驱动着整个 Windows 用户界面的交互\n消息特征：\n用途：用于通知应用程序发生了某个“有趣的事情”。这些事情大多与用户输入或窗口状态变化有关。 结构：一个消息通常是一个MSG结构体，包含以下关键信息： hwnd: 消息的目标窗口句柄。 message: 消息的类型（一个唯一的ID，如 WM_KEYDOWN, WM_LBUTTONDOWN, WM_PAINT）。 wParam: 附加信息1（具体含义取决于消息类型）。 lParam: 附加信息2（具体含义取决于消息类型）。 来源： 硬件输入：鼠标移动、点击，键盘按下等。操作系统捕获硬件中断，将其转化为消息。 系统通知：窗口需要重绘 (WM_PAINT)，窗口被销毁 (WM_DESTROY)。 程序内部：程序可以自己给自己或其他窗口发送/投递消息（使用 SendMessage 或 PostMessage）。 处理流程 (消息循环)： 操作系统将消息放入对应线程的消息队列 (Message Queue) 中。 应用程序的消息循环 (while (GetMessage(...))) 从队列中取出消息。 DispatchMessage 将消息派发给目标窗口的窗口过程函数 (WndProc)。 WndProc 根据消息类型执行相应的处理代码 两者对比\n特性 事件 (Event) 消息 (Message) 层面 内核层 (Kernel) GUI/用户层 (USER32) 本质 同步对象 (Synchronization Object) 数据结构 (Data Structure) 目的 线程间同步，协调执行顺序 通知窗口发生了某事，驱动UI响应 状态/内容 只有两种状态：已触发/未触发 包含丰富信息：目标窗口、类型、参数 通信方 线程 vs 线程 (或 进程 vs 进程) 系统/用户 vs 窗口 (或 窗口 vs 窗口) 处理方式 线程通过 WaitFor... 等待，然后继续执行 窗口的 WndProc 被动接收并处理 典型例子 一个线程完成下载后，触发一个事件，通知主线程可以更新UI了 用户点击鼠标，系统向窗口发送 WM_LBUTTONDOWN 消息 MSG结构体：\n1 2 3 4 5 6 7 8 typedef struct tagMAG { HWND hwnd;\t//窗口句柄 UNIT message;\t//消息类型 WPARAM wParam; LPARAM lParam; DWORD time;\t//事件什么时候发生 POINT pt;\t//坐标（鼠标位置） } MSG, *PMSG; 消息类型\n首先，Windows 消息都以 WM_（Window Message）为前缀，这使得它们非常容易辨认。比如 WM_CREATE, WM_PAINT, WM_KEYDOWN\n窗口管理消息 (Window Management Messages) 用户输入消息 (User Input Messages) 键盘消息 鼠标消息 绘图消息 (Painting Messages) 控件通知消息 (Control Notification Messages) 用户自定义消息 (User-Defined Messages) 剪贴板消息 (Clipboard Messages) Windows 系统消息队列与应用程序消息队列：事件触发 -\u0026gt; MSG -\u0026gt;系统消息队列 -\u0026gt; 应用消息队列 -\u0026gt; 消息循环 -\u0026gt; 处理消息\nWin32 GUI Java GUI 编程和 Win32 GUI 编程在最终目标（创建图形用户界面）上是相似的，但在实现方式、抽象层次、开发体验、跨平台性和底层机制上存在巨大差异，可以说是两种截然不同的范式\n抽象层次与直接性： Win32 GUI： 极其底层。开发者直接调用 Windows 操作系统提供的原生 API（主要是 user32.dll 和 gdi32.dll）。你需要：\n手动注册窗口类 (RegisterClassEx)。 手动创建窗口 (CreateWindowEx)。 编写庞大的消息循环 (GetMessage, TranslateMessage, DispatchMessage)。 在复杂的窗口过程 (WndProc) 函数中处理大量的 Windows 消息 (WM_CREATE, WM_PAINT, WM_COMMAND, WM_SIZE, WM_DESTROY 等)。 直接管理窗口句柄 (HWND)、设备上下文 (HDC)、画笔 (HPEN)、画刷 (HBRUSH) 等底层资源。 显式处理资源释放和内存管理。 Java GUI (Swing/JavaFX)： 高度抽象。开发者使用 Java 提供的 GUI 工具包： Swing： 基于 AWT，提供了一套纯 Java 实现的、可插拔外观的组件 (JFrame, JButton, JTextField, JTable 等)。开发者主要操作对象 (JButton btn = new JButton(\u0026quot;Click Me\u0026quot;)) 和事件监听器 (btn.addActionListener(...))。Swing 内部处理了与原生系统的交互。 JavaFX： 更现代、功能更强大的 GUI 工具包，同样基于对象 (Stage, Scene, Button, TextField, TableView 等)。它使用场景图 (Scene Graph) 模型、CSS 样式、FXML 声明式布局、丰富的图形/媒体/3D 支持，以及绑定 (Binding) 等高级特性。开发者主要关注业务逻辑和界面描述，底层渲染细节由 JavaFX 引擎处理（可以使用硬件加速）。 事件处理模型： Win32 GUI： 基于消息传递。所有用户交互（点击、按键、移动鼠标、重绘请求）都转化为特定的 WM_* 消息，被投递到应用程序的消息队列中。你的窗口过程 (WndProc) 必须检查每条消息 (msg.message)，使用巨大的 switch-case 或 if-else 结构来处理它们。处理逻辑与窗口创建代码紧密耦合。\nJava GUI (Swing/JavaFX)： 基于事件监听/回调。采用 观察者模式。 你为特定的 UI 组件 (Button, TextField) 注册事件监听器 (ActionListener, MouseListener, KeyListener, ChangeListener 等)。 当用户与组件交互时（如点击按钮），组件会触发一个事件对象 (ActionEvent, MouseEvent)。 你注册的监听器方法 (actionPerformed(ActionEvent e), mouseClicked(MouseEvent e)) 会被自动调用，你只需在这些方法中编写响应事件的逻辑。事件源（哪个组件）和事件类型（点击、移动等）由事件对象携带。 这种方式更符合面向对象思想，代码组织更清晰，将事件处理逻辑与 UI 构建逻辑解耦。 Windows窗口实现\n1.创建Windows应用程序，选择空项目\n2.在新建窗口中选C++代码文件，创建一个新的cpp\n3.在文件中添加：#include \u0026lt;Windows.h\u0026gt;\n添加入口函数\n1 2 3 4 5 6 int CALLBACK WinMain(_In_ HINSTANCE hInstance,\t//#define CALLBACK\t__stdcall _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow) { return 0; } 4.设计窗口类\nWNDCLASS 结构体的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 typedef struct tagWNDCLASS { UINT style; // 窗口类的样式 WNDPROC lpfnWndProc; // 指向窗口过程函数的指针 int cbClsExtra; // 附加的类内存 int cbWndExtra; // 附加的窗口内存 HINSTANCE hInstance; // 拥有该类的实例句柄 HICON hIcon; // 类图标的句柄 HCURSOR hCursor; // 类光标的句柄 HBRUSH hbrBackground; // 类背景画刷的句柄 LPCTSTR lpszMenuName; // 菜单资源的名称 LPCTSTR lpszClassName; // 窗口类的名称 } WNDCLASS, *PWNDCLASS; 代码实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 #include \u0026lt;Windows.h\u0026gt; LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);\t//声明窗口过程函数 int APIENTRY wWinMain(_In_ HINSTANCE hInstance, _In_opt_ HINSTANCE hPrevInstance, _In_ LPWSTR lpCmdLine, _In_ int nCmdShow) { //定义并注册窗口类 TCHAR CLASS_NAME[] = L\u0026#34;MyFisrtWindowC\u0026#34;; WNDCLASS wndclass = { 0 };\t//若不初始化所有成员则无法创建 wndclass.hbrBackground = (HBRUSH)COLOR_MENU; //背景色 wndclass.lpfnWndProc = WindowProc; //事件触发时由该函数处理(窗口过程函数) wndclass.lpszClassName = CLASS_NAME; //窗口类名 wndclass.hInstance = hInstance; //当前窗口绑定的应用程序(当前实例) wndclass.hCursor = LoadCursor(NULL, IDC_ARROW); // 箭头光标 RegisterClass(\u0026amp;wndclass); //注册窗口类 //创建窗口 HWND hwnd = CreateWindowEx( 0, // 扩展样式 CLASS_NAME, // 注册的类名 L\u0026#34;我的Win32窗口\u0026#34;, // 窗口标题 WS_OVERLAPPEDWINDOW, // 窗口样式 // 位置和大小 CW_USEDEFAULT, CW_USEDEFAULT, 400, 300, NULL, // 父窗口句柄 NULL, // 菜单 hInstance, // 实例句柄 NULL // 附加数据 ); if (hwnd == NULL) return 0; //显示窗口 ShowWindow(hwnd, nCmdShow); UpdateWindow(hwnd); //消息循环 MSG msg = { 0 }; while (GetMessage(\u0026amp;msg, NULL, 0, 0)) { TranslateMessage(\u0026amp;msg); DispatchMessage(\u0026amp;msg); } return 0; } //实现窗口过程函数(回调函数) LRESULT CALLBACK WindowProc( HWND hwnd, // 窗口句柄 UINT uMsg, // 消息类型 WPARAM wParam, // 附加信息 LPARAM lParam) // 附加信息 { switch (uMsg) { // 处理关闭消息 case WM_DESTROY: PostQuitMessage(0); // 退出消息循环 return 0; // 处理绘制消息 case WM_PAINT: { PAINTSTRUCT ps; HDC hdc = BeginPaint(hwnd, \u0026amp;ps); // 在此处绘制内容（例如文字） TextOut(hdc, 50, 50, L\u0026#34;Hello, Win32!\u0026#34;, 13); EndPaint(hwnd, \u0026amp;ps); return 0; } // 默认处理其他消息 default: return DefWindowProc(hwnd, uMsg, wParam, lParam); } } 参考\nWin32 - 滴水逆向课程笔记\n","date":"0001-01-01T00:00:00Z","image":"https://567liuhuaqing.github.io/p/win32/%E8%88%B9%E9%95%BF_hu_cf39e48f39757e58.jpg","permalink":"https://567liuhuaqing.github.io/p/win32/","title":"Win32"}]