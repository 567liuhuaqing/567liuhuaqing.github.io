[{"content":"在C++开发中，库（Library）是代码复用的重要方式，库的存在形式本质上来说库是一种可执行代码的二进制，分为静态库（.lib、.a）和动态库（.dll、.so）\n静态链接库 静态库是一种在编译时将代码直接嵌入到可执行文件中的库文件，它具有独立性、性能优势和版本控制等特点，适用于许多不同类型的项目和开发环境。如果你想要别人使用你的代码，但又不想将源代码公开的时候，也可以使用\n优：静态写入封装，代码重用\n缺：直接编译到exe（如若修改.lib，需重新编译exe）\n创建静态链接库 这里以Visual Studio 2022为例\n方法一： 首先创建新项目模板为**”静态库“** 也可以在项目属性页修改配置类型\n若要自定义头文件，C/C++ → 预编译头 → 设置为\u0026quot;不使用预编译头\u0026quot;\n在pch.h中添加函数或类预定义\n1 2 3 4 5 6 7 #pragma once void PPTe(); namespace test { void castue(); } 在pch.cpp中写出完整的类与方法\n1 2 3 4 5 6 7 8 9 10 11 12 13 #include \u0026lt;iostream\u0026gt; #include \u0026#34;pch.h\u0026#34; using namespace std; void PPTe(){ cout \u0026lt;\u0026lt; \u0026#34;Hello World \u0026#34; \u0026lt;\u0026lt; endl; } namespace test { void castue() { cout \u0026lt;\u0026lt; \u0026#34;Ualeo Teui\u0026#34; \u0026lt;\u0026lt; endl; } } 选择“生成” -\u0026gt; “生成解决方案”（Ctrl+Shift+B）\n在“x64” -\u0026gt; “Debug”中生成lib文件如下\n然后创建一个新项目**“控制台应用”** 将刚刚生成的lib文件和头文件打包复制到新项目文件夹\n在源文件中预定义头文件，并且在代码中指定需要链接的库文件，添加代码为\n1 2 #include \u0026#34;pch.h\u0026#34; #pragma comment(lib, \u0026#34;TestLib.lib\u0026#34;) 这样就成功导入静态链接库啦，可以使用静态库中的类与方法\n方法二： 刚刚的指定需要链接的库文件代码不添加\n将头文件和库文件打包在同一个文件夹，将该文件夹路径添加到项目属性 → VC++目录 → 包含目录和库目录，注意前面要加; （如果是方法一中直接复制文件到新项目就跳过此步）\n项目属性中设置：打开项目属性 → 链接器 → 输入，在\u0026quot;附加依赖项\u0026quot;中添加 TestLib.lib\n或者打开项目属性 → 链接器 → 命令行，在“其他选项”中添加 TestLib.lib\n点击“应用” → “确定”，和上述功能相同\n动态链接库 动态库指的是在程序运行过程中动态加载库的方式使用的库，也就是动态库的链接是发生在程序运行时期的，它和可执行文件是分开的，只是可执行文件在运行的某个时期调用了它。\n优：程序自身的体积不会因为动态函数库变大\n缺：就是程序运行过程中使用到了这些函数库内的功能时，若系统特定的位置没有对应的动态库，就会造成程序崩溃或者各种奇怪的问题\n创建动态链接库 方法一：隐式调用 创建新项目模板为**”动态链接库“**\n或配置属性 → 常规 → 配置类型：动态库(.dll)\n函数声明与生成静态库不一样\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 #pragma once // DLL导出宏 #ifdef STRINGDYNAMICLIB_EXPORTS\t//若使用该语句，C/C++ → 预处理器 → 预处理器定义：添加STRINGDYNAMICLIB_EXPORTS #define STRING_API __declspec(dllexport)\t//导出声明(__declspec(dllexport))告诉编译器哪些函数应该对外可见，没有导出的函数无法从外部调用 #else #define STRING_API __declspec(dllimport) #endif namespace StringDynamic { STRING_API void reverse(char* str, int length);\t// 反转字符串 STRING_API int countChar(const char* str, char c);\t// 统计字符出现次数 STRING_API char* concatenate(const char* str1, const char* str2);\t// 连接两个字符串 } .cpp代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include \u0026#34;pch.h\u0026#34; #include \u0026lt;cstring\u0026gt; #include \u0026lt;cstdlib\u0026gt; namespace StringDynamic { STRING_API void reverse(char* str, int length) { int start = 0; int end = length - 1; while (start \u0026lt; end) { std::swap(str[start], str[end]); start++; end--; } } STRING_API int countChar(const char* str, char c) { int count = 0; while (*str) { if (*str == c) count++; str++; } return count; } STRING_API char* concatenate(const char* str1, const char* str2) { size_t len1 = strlen(str1); size_t len2 = strlen(str2); char* result = (char*)malloc(len1 + len2 + 1); strcpy(result, str1); strcat(result, str2); return result; } } 选择“生成” -\u0026gt; “生成解决方案”（Ctrl+Shift+B），会生成dll文件和lib\n同样创建一个新项目，将dll和lib打包复制到新项目文件夹中\n1 2 3 #pragma comment(lib, \u0026#34;TestDll.lib\u0026#34;) extern \u0026#34;C\u0026#34; _declspec(dllimport) int __stdcall mySub(int x, int y);\t//导入函数时要跟声明类型的一样 方法二：显示调用 dll文件为方法一中生成的，将dll与exe放于同一目录\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;windows.h\u0026gt; //使用LoadLibrary函数必须包含此头文件 #include \u0026lt;iostream\u0026gt; using namespace std; typedef int(__stdcall* lpSub)(int, int); //定义函数指针 int main() { lpSub mySub;\t//声明函数指针变量\t//动态加载dll到内存 HINSTANCE hModule = LoadLibrary(L\u0026#34;TestDll.dll\u0026#34;); //L -\u0026gt; 宽字符版本 -\u0026gt; 现代Windows兼容 mySub = (lpSub)GetProcAddress(hModule, \u0026#34;mySub\u0026#34;); //获取函数地址 cout \u0026lt;\u0026lt; \u0026#34;2-1=\u0026#34; \u0026lt;\u0026lt; mySub(2, 1) \u0026lt;\u0026lt; endl; //若是32位程序，__stdcall类型则为_mySub@8 } 静态库与动态库对比 使用.def导出库 同样使用动态链接库项目，def导出可以隐藏函数名\npch.h\n1 int myMul(int x, int y); pch.cpp\n1 2 3 int myMul(int x, int y) { return x * y; } test.def\n1 2 3 EXPORTS Mul @13\tNONAME\t//13为该函数序号 NONAME表示没有名字，即隐藏函数名 配置属性 → 链接器 → 输入中模块定义文件添加刚刚的test.def\n选择“生成” -\u0026gt; “生成解决方案”（Ctrl+Shift+B），显示调用代码为\n1 2 3 4 5 6 7 8 9 10 #include \u0026lt;windows.h\u0026gt; //使用LoadLibrary函数必须包含此头文件 #include \u0026lt;iostream\u0026gt; using namespace std; typedef int(*lpMul)(int, int); //定义函数指针 int main() { lpMul myMul; //声明函数指针变量 //动态加载dll到内存 HINSTANCE hModule = LoadLibrary(L\u0026#34;TestDll2.dll\u0026#34;); //L -\u0026gt; 宽字符版本 -\u0026gt; 现代Windows兼容 myMul = (lpMul)GetProcAddress(hModule, MAKEINTRESOURCEA(13));\t//通过序号获取函数地址 cout \u0026lt;\u0026lt; \u0026#34;2*1=\u0026#34; \u0026lt;\u0026lt; myMul(2, 1) \u0026lt;\u0026lt; endl; } 通过序号调用可隐藏函数名~\n参考\nVisual Studio 2022静态库与动态库创建及使用完全指南\n","date":"2025-07-15T00:00:00Z","image":"https://567liuhuaqing.github.io/p/%E5%BA%93/%E7%93%B7%E5%BF%83%E5%82%80%E5%84%A1_hu_5b1bc5e98d737dd1.jpg","permalink":"https://567liuhuaqing.github.io/p/%E5%BA%93/","title":"库"},{"content":"PE结构概述 程序入口地址OEP\nPE分节 节省硬盘空间 节省内存空间 PEloader-\u0026gt;PE加载 根据SizeOfImage的大小，开辟一块缓冲区（ImageBuffer） 根据SizeOfHeader的大小，将头信息从FileBuffer拷贝到ImageBuffer 根据节表中的信息循环将FileBuffer中的节拷贝到ImageBuffer中 RVA转化成FOA VA：英文全称是Virual Address，简称VA，中文意思是虚拟地址。指的是文件被载入虚拟空间后的地址。\nImageBase：中文意思是基址，指的是程序在虚拟空间中被装载的位置。\nRVA：英文全称是Relative Virual Address，简称RVA，中文意思是相对虚拟地址。可以理解为文件被装载到虚拟空间(拉伸)后先对于基址的偏移地址。计算方式：RVA = VA(虚拟地址) - ImageBase(基址)。它的对齐方式一般是以1000h为单位在虚拟空间中对齐的(传说中的4K对齐)，具体对齐需要参照IMAGE_OPTIONAL_HEADER32中的SectionAlignment成员。\nFOA：英文全称是File Offset Address，简称FOA，中文意思是文件偏移地址。可以理解为文件在磁盘上存放时相对于文件开头的偏移地址。它的对齐方式一般是以200h为单位在硬盘中对齐的(512对齐)，具体对齐需要参照IMAGE_OPTIONAL_HEADER32中的FileAlignment成员。\n全局变量：如果全局变量没有初始化值，那么这个全局变量在PE文件中是没有保存它的位置的，如果有初始化那么就有它位置保存初始值。定位到全局变量的位置后即可修改。\nFOA(文件偏移，基于PE文件开始的地址0)和RVA(虚拟地址偏移，基于ImageBase)：\n当SectionAlignment（内存中节区对齐大）和FileAlignment（文件中节区对齐大）相同时，这2个偏移相同，现在的大部分程序都相同.\n如果不相同时：要判断是否在PE头中，如果在PE头这个节区那么他们还是相同，如果不在PE头节区，RVA先算出当前虚拟地址相对与当前节区的开始地址的偏移，然后在文件中也找到这个节区在PE文件中的偏移位置加上相同的偏移即可。\n就算SectionAlignment（内存中节区对齐大）和FileAlignment（文件中节区对齐大）相同时，每个节区加载地址也可能不同这时还是要自己转换RVA和FOA\n作业见PE加载与回收+RVA转换成FOA.cpp\nPE头字段说明 DOS头 文件开始的地方\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 1\tDOS头\t//滴水\t//我自己 typedef struct _IMAGE_DOS_HEADER { WORD e_magic; *\t//Magic number(MZ);\t//5A4D WORD e_cblp;\t//Bytes on last page of file\t//0090 WORD e_cp; //Pages in file\t//0003 WORD e_crlc; //Relocations\t//0000 WORD e_cparhdr;\t//Size of header in paragraphs\t//0004 WORD e_minalloc; //Minimum extra paragraphs needed\t//0000 WORD e_maxalloc;\t//Maximum extra paragraphs needed\t//FFFF WORD e_ss; //Initial (relative) SS value\t//0000 WORD e_sp;\t//Initial SP value\t//00B8 WORD e_csum;\t//Checksum\t//0000 WORD e_ip;\t//Initial IP value\t//0000 WORD e_cs;\t//Initial (relative) CS value\t//0000 WORD e_lfarlc;\t//File address of relocation table\t//0040 WORD e_ovno;\t//Overlay number\t//0000 WORD e_res[4];\t//Reserved words\t//0000 0000 0000 0000 WORD e_oemid;\t//OEM identifier (for e_oeminfo)\t//0000 WORD e_oeminfo;\t//OEM information; e_oemid specific\t//0000 WORD e_res2[10];\t//Reserved words\t//0000 0000 0000 0000 0000 0000 0000 0000 0000 0000 DWORD e_lfanew; *\t//File address of new exe header //0000 00E8\t-\u0026gt;\t//0000 0108 } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER; NT头/PE头 NT头 = PE标志+ 标准PE头 + 可选PE头\nDOS头字段e_lfanew为PE头开始的地方\n1 2 3 4 5 typedef struct _IMAGE_NT_HEADERS { DWORD Signature; //NT头标志 即\u0026#39;PE..\u0026#39; 00004550 IMAGE_FILE_HEADER FileHeader; //标准PE头 IMAGE_OPTIONAL_HEADER32 OptionalHeader; //扩展PE头 } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32; 标准PE头/文件头 1 2 3 4 5 6 7 8 9 10 2\t标准PE头 typedef struct _IMAGE_FILE_HEADER { WORD Machine; * //程序运行的CPU型号 x86CPU:0x14C x64CPU:0x8864 WORD NumberOfSections; * //PE中节的数量 DWORD TimeDateStamp; * //时间戳：文件创建的日期和时间 DWORD PointerToSymbolTable; //执行符号表，即编译好的程序生成的pdb文件，用来方便调试的 DWORD NumberOfSymbols; //符号表中的符号数量 WORD SizeOfOptionalHeader; * //可选PE头的大小 x86（32位）:224字节 x64（64位）:240字节 WORD Characteristics; * //文件属性，每个位有不同的含义 x86:0x3 x64:0x22 } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER; 可选PE头/扩展头 标准PE头字段SizeOfOptionalHeader为可选PE头大小（32位：E0h字节 / 64位：F0h字节）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 3\t可选PE头 typedef struct _IMAGE_OPTIONAL_HEADER { WORD Magic; * //魔数 x86:0x10B x64:0x20B BYTE MajorLinkerVersion; //链接器的版本 BYTE MinorLinkerVersion; //连接器的版本 DWORD SizeOfCode; * //所有代码区段的大小总和，必须是FileAlignment的整数倍 DWORD SizeOfInitializedData; * //已经初始化数据区段大小总和，必须是FileAlignment的整数倍 DWORD SizeOfUninitializedData; * //未初始化数据区段大小总和，必须是FileAlignment的整数倍 DWORD AddressOfEntryPoint; ** //程序入口OEP+ImageBase DWORD BaseOfCode; * //代码段的起始RVA DWORD BaseOfData; * //数据段的起始RVA（32+PE删除了） DWORD ImageBase; ** //程序建议的加载地址（内存镜像基地址） x64 ULONGLONG DWORD SectionAlignment; ** //内存中的对齐粒度 x86 0x1000 x64 0x2000 DWORD FileAlignment; ** //文件中的对齐粒度 0x200 WORD MajorOperatingSystemVersion; //操作系统版本号 WORD MinorOperatingSystemVersi on; WORD MajorImageVersion; //PE的镜像备案本号 WORD MinorImageVersion; WORD MajorSubsystemVersion; //子系统的版本号。 WORD MinorSubsystemVersion; DWORD Win32VersionValue; //Win32版本（未使用） DWORD SizeOfImage; ** //内存中整个PE镜像的尺寸，必须是SectionAlignment的整数倍 DWORD SizeOfHeaders; ** //所有头+节表按照文件对齐后的大小 DWORD CheckSum; * //校验和 WORD Subsystem; //子系统，其决定了程序入口点main函数的不同，常见的子系统有窗口，控制台等等 WORD DllCharacteristics; //DLL动态链接库特性 DWORD SizeOfStackReserve; * //初始化时的栈大小 DWORD SizeOfStackCommit; * //初始化时实际上提交的栈大小 DWORD SizeOfHeapReserve; * //初始化时保留的堆大小 DWORD SizeOfHeapCommit; * //初始化时实际上提交的堆大小 DWORD LoaderFlags; //加载标记 DWORD NumberOfRvaAndSizes; * //数据目录结构的数量 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; //数据目录表数组 } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32; 最重要属性\n1 2 3 4 5 6 7 8 DWORD AddressOfEntryPoint; ** //程序入口OEP+ImageBase DWORD ImageBase; ** //程序建议的加载地址（内存镜像基地址） DWORD SectionAlignment; ** //内存中的对齐粒度 x86 0x1000 x64 0x2000 DWORD FileAlignment; ** //文件中的对齐粒度 0x200 DWORD SizeOfImage; ** //内存中整个PE文件的映像（镜像）的尺寸，必须是SectionAlignment的整数倍 DWORD SizeOfHeaders; ** //所有头+节表按照文件对齐后的大小 DWORD NumberOfRvaAndSizes; * //数据目录结构的数量 IMAGE_DATA_DIRECTORY DataDirectory[IMAGE_NUMBEROF_DIRECTORY_ENTRIES]; //数据目录表数组（16*8字节） 节表 可选PE头结束后紧跟着的地方为节表，标准PE表中字段NumberOfSections为节表个数，一个节表大小为40个字节\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #define IMAGE_SIZEOF_SHORT_NAME 8 //宏定义 typedef struct _IMAGE_SECTION_HEADER{ BYTE Name[IMAGE_SIZEOF_SHORT_NAME]; *\t//每一个节都可以取一个名字，最大长度为8字节 union{\t//联合体（大小为最大属性的大小） DWORD PhysicalAddress; DWORD VirtualSize; } Misc; *\t//是该节在没有对齐前的真实尺寸（若被修改则不准确） DWORD VirtualAddress; *\t//节在内存中的偏移地址（相对偏移） DWORD SizeOfRawData; *\t//节在文件中对齐后的尺寸 DWORD PointerToRawData; *\t//节在文件中的偏移 DWORD PointerToRelocations; DWORD PointerToLinenumbers; WORD NumberOfRelocations; WORD NumberOfLinenumbers; DWORD Characteristics; *\t//节的属性 } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER; 打印所有头和节表代码详见打印PE头.cpp，运行如下\n空白区添加代码 代码节空白区添加代码 1.MessageBox函数说明 MessageBox()函数：功能是弹出一个标准的Windows对话框；它不是C函数库的标准函数，而是一个API，我们可以用C语言调用API函数。可以理解成我们在C中使用MessageBox函数就表示调用系统提供的API函数–MessageBoxA。包含在头文件windows.h；如果一个程序中包含user32.dll，则此程序就有MessageBoxAAPI函数\n2.函数原型\n1 int MessageBox( HWND hWnd,LPCTSTR lpText, LPCTSTR lpCaption = NULL, UINT nType = MB_OK ); 获取MessageBox地址，构造ShellCode代码 E8 E9计算公式，x=MessageBox地址-下一条指令在内存中的地址 在代码区手动添加代码 修改OEP，指向ShellCode 任意节空白区添加代码 新增节添加代码 SizeOfHeader - (DOS + 垃圾数据 + PE标记 + 标准PE头 + 可选PE头 + 已存在的节表) \u0026gt;= 2个节表的大小 需要修改的数据 1）添加一个新的节\n2）在新增节后面，填充一个节大小的000\n3）修改PE头中节的数量NumberOfSections\n4）修改ImageBase的大小\n5）在原有数据的最后，新增一个节的数据为内存对齐的整数倍\n6）修正新增节表的属性\n扩大节-合并节-数据目录 扩大节\n拉伸到内存\n分配一块新的空间：SizeOfImage + Ex\n将最后一个节的SizeOfRawData和VirtualSize改成N\n其中 N = MAX（SizeOfRawData，VirtualSize）内存对齐 + Ex\n修改SizeOfImage\n合并节\n拉伸到内存\n将第一个节的内存大小、文件大小改成一样\nMax = SizeOfRawData\u0026gt;VirtualSize?SizeOfRawData:VirtualSize\nSizeOfRawData = VirtualSize = 最后一个节的VirtualAddress + Max - SizeOfHeaders内存对齐的大小\n将第一个节的属性改为包含所有节的属性\n修改节的数量为1\n","date":"2025-07-06T00:00:00Z","image":"https://567liuhuaqing.github.io/p/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/%E6%AF%8D%E7%A5%9E%E5%82%A9_hu_17a824fd97ed2b91.jpg","permalink":"https://567liuhuaqing.github.io/p/pe%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84/","title":"PE文件结构"},{"content":"汇编 数据宽度\nBYTE WORD DWORD 8bit 16bit 32bit $$ *寻址范围-\u003e32位or64位* $$\n汇编指令 mov lea add sub 取数据 取地址 加 减 and or xor not \u0026amp; | ^ ! 进阶\n指令格式 功能 ADC R/M,R/M/IMM 带进位加法 SBB R/M,R/M/IMM 带借位减法 XCHG R/M,R/M 交换数据 MOVS B/W/D :[EDI],:[ESI] 移动数据（内存-内存）（[EDI]/[ESI]根据方向标志DF决定自增/减） STOS B/W/D :[EDI] 将AL/AX/EAX的值储存到[EDI]指定的内存单元 REP MOVSD/STOSB/\u0026hellip; 按计数寄存器（ECX）中指定的次数重复执行字符串指令 类型转换 功能 MOVSX CX, AL 符号拓展 MOVZX CX, AL 无符号拓展 内存的读写\nMOV DWORD ptr ds:[0x0012FFC4], 0x12345678\n汇编、寄存器、堆栈窗口大端序；数据窗口小端序\n寻址公式 [立即数] [reg] -\u0026gt; dword ptr ds:[ecx] [reg+立即数] -\u0026gt; dword ptr ds:[ecx+4] [reg+reg*{1, 2, 4, 8}] -\u0026gt; dword ptr ds:[eax+ecx*4] [reg+reg*{1, 2, 4, 8}+立即数] -\u0026gt; dword ptr ds:[eax+ecx*4+4] 标志寄存器 各类标志寄存器 值为1的条件 进位标志CF 运算结果最高位产生一个进位或借位 奇偶标志PF 运算结果中“1”的个数为偶数 辅助进位标志AF 在字/字节操作时，低字节/4位向高字节/4位进位或借位 零标志ZF 运算结果为0 符号标志SF 与运算结果的最高位相同 溢出标志OF 有符号数加减运算是否溢出 常见汇编及JCC 常见汇编 JMP 寄存器/立即数 修改EIP的值 CALL [A]/寄存器 PUSH [B] MOV EIP,[A]/寄存器 RET -\u0026gt; POP EIP CMP R/M,R/M/IMM TEST R/M,R/M/IMM JCC 条件 标志 JE，JZ 结果为零则跳转 ZF=1 JNE，JNZ 结果不为零则跳转 ZF=0 JS 结果为负则跳转 SF=1 JNS 结果为非负则跳转 SF=0 JP，JPE 结果中1的个数为偶数则跳转 PF=1 JNP，JPO 结果中1的个数为奇数则跳转 PF=0 JO 结果溢出了则跳转 OF=1 JNO 结果没有溢出则跳转 OF=0 JB，JNAE 小于则跳转（无符号数） CF=1 JNB，JAE 大于等于则跳转（无符号数） CF=0 JBE，JNA 小于等于则跳转（无符号数） CF=1 or ZF=1 JNBE，JA 大于则跳转（无符号数） CF=0 and ZF=0 JL，JNGE 小于则跳转（有符号数） SF!=OF JNL，JGE 大于等于则跳转（有符号数） SF=OF JLE，JNG 小于等于则跳转（有符号数） ZF=1 or SF!=OF JNLE，JG 大于则跳转（有符号数） ZF=0 and SF=OF 堆栈 push R/M\npop R/M\nesp 栈顶 / ebp 栈底\n无参函数 汇编代码 功能 call 00E71316 调用函数（无参） jmp 00E723D0 00E723D0 push ebp 00E723D1 mov ebp,esp 00E723D3 sub esp,0C0h 提升堆栈 00E723D9 push ebx 00E723DA push esi 00E723DB push edi 保留现场 00E723DC mov edi,ebp 00E723DE xor ecx,ecx 00E723E0 mov eax,0CCCCCCCCh 00E723E5 rep stos dword ptr es:[edi] 00E723E7 mov ecx,0E7E069h 00E723EC call 00E71389 为缓冲区填充数据 00E723F2 pop edi 00E723F3 pop esi 00E723F4 pop ebx 恢复现场 00E723F5 add esp,0C0h 00E723FB cmp ebp,esp 00E723FD call 00E7128F 检查堆栈平衡 00E72402 mov esp,ebp 00E72404 pop ebp 降低堆栈 00E72405 ret 函数返回 有参函数（加法） 汇编代码 功能 000B1D35 push 2 000B1D37 push 1 参数 000B1D39 call 000B143D 调用函数 000B1D3E add esp,8 平衡堆栈 000B143D jmp 000B1CC0 中转 000B1CC0 push ebp 000B1CC1 mov ebp,esp 000B1CC3 sub esp,0C0h 000B1CC9 push ebx 000B1CCA push esi 000B1CCB push edi 000B1CCC mov edi,ebp 000B1CCE xor ecx,ecx 000B1CD0 mov eax,0CCCCCCCCh 000B1CD5 rep stos dword ptr es:[edi] 000B1CD7 mov ecx,0BE069h 000B1CDC call 000B1389 000B1CE1 nop 000B1CE2 mov eax,dword ptr [ebp+8] 000B1CE5 add eax,dword ptr [ebp+0Ch] eax中存储的就是返回值 000B1CE8 pop edi 000B1CE9 pop esi 000B1CEA pop ebx 000B1CEB add esp,0C0h 000B1CF1 cmp ebp,esp 000B1CF3 call 000B128F 000B1CF8 mov esp,ebp 000B1CFA pop ebp 000B1CFB ret 嵌套函数 汇编代码 功能 00761D45 push 3 00761D47 push 2 00761D49 push 1 参数 00761D4B call plus2 (0761442h) 调用函数 00761D50 add esp,0Ch 平衡堆栈 00761442 jmp plus2 (0762490h) 中转 00762490 push ebp 00762491 mov ebp,esp 00762493 sub esp,0CCh 00762499 push ebx 0076249A push esi 0076249B push edi 0076249C lea edi,[ebp-0Ch] 0076249F mov ecx,3 007624A4 mov eax,0CCCCCCCCh 007624A9 rep stos dword ptr es:[edi] 007624AB mov ecx,76E069h 007624B0 call 00761389 007624B5 nop 12: int t = plus1(a, b);007624B6 mov eax,dword ptr [ebp+0Ch] eax=2 007624B9 push eax 2入栈（参数） 007624BA mov ecx,dword ptr [ebp+8] ecx=1 007624BD push ecx 1入栈（参数） 007624BE call plus1 (076143Dh) 函数调用 007624C3 add esp,8 平衡堆栈 007624C6 mov dword ptr [ebp-8],eax eax是plus1返回结果，ebp-8是局部变量t 13: return plus1(t, c);007624C9 mov eax,dword ptr [ebp+10h] 007624CC push eax 007624CD mov ecx,dword ptr [ebp-8] 007624D0 push ecx 007624D1 call 0076143D 007624D6 add esp,8 同上 0076143D jmp plus1 (00761CC0h) 00761CC0 push ebp 00761CC1 mov ebp,esp 00761CC3 sub esp,0C0h 00761CC9 push ebx 00761CCA push esi 00761CCB push edi 00761CCC mov edi,ebp 00761CCE xor ecx,ecx 00761CD0 mov eax,0CCCCCCCCh 00761CD5 rep stos dword ptr es:[edi] 00761CD7 mov ecx,76E069h 00761CDC call 00761389 00761CE1 nop 9: return a + b;00761CE2 mov eax,dword ptr [ebp+8] 00761CE5 add eax,dword ptr [ebp+0Ch] 00761CE8 pop edi 00761CE9 pop esi 00761CEA pop ebx 00761CEB add esp,0C0h 00761CF1 cmp ebp,esp 00761CF3 call 0076128F 00761CF8 mov esp,ebp 00761CFA pop ebp 00761CFB ret plus1(t, c) 007624D9 pop edi 007624DA pop esi 007624DB pop ebx 007624DC add esp,0CCh 007624E2 cmp ebp,esp 007624E4 call 0076128F 007624E9 mov esp,ebp 007624EB pop ebp 007624EC ret 裸函数及其调用约定 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 void __declspec(naked) plus(/*int x, int y, int z*/) { //裸函数 __asm { /* push ebp; //提升堆栈 mov ebp, esp; sub esp, 0x40; push ebx; //保留现场 push esi; push edi; mov eax, 0xCCCCCCCC; //填充缓冲区 mov ecx, 0x10; lea edi, dword ptr ds : [ebp - 0x40] ; rep stosd; mov eax, dword ptr ds : [ebp + 8] ; //函数功能\tx add eax, dword ptr ds : [ebp + 0xC] ;\t//y add eax, dword ptr ds : [ebp + 0x10] ;\t//z //__emit 0xe8; pop edi; //恢复现场 pop esi; pop edx; mov esp, ebp; //降低堆栈 pop ebp; */ ret; } } 调用约定 参数压栈顺序 平衡堆栈 __cdecl 从右至左入栈 调用者清理栈 __stdcall 从右至左入栈 自身清理堆栈-\u0026gt;ret 8 __fastcall ecx/edx传送前两个\n剩下：从右至左入栈 自身清理堆栈 内存图\nif，else，while 代码区 参数，局部变量，临时数据 堆栈 动态申请的，大小可变的\n可读，可写 堆 可读，可写 全局变量区 只读 常量区 位运算\n算数移位 指令格式 逻辑移位 指令格式 溢出位进CF SAL/SAR R/M,CL/I 溢出位进CF SHL/SHR R/M,CL/I 算数左移 SAL（补0） 逻辑左移 SHL（补0） 算数右移 SAR（补符号位） 逻辑右移 SHR（补0） 循环移位 指令格式 带进位循环 指令格式 溢出位进CF ROL R/M, I\nROR R/M, CL 溢出位进CF RCL R/M, I\nRCR R/M, CL 循环左移 ROL（补溢出位） 左移 RCL（补CF位） 循环右移 ROR（补溢出位） 右移 RCR（补CF位） ","date":"2025-05-12T00:00:00Z","image":"https://567liuhuaqing.github.io/p/%E6%B1%87%E7%BC%96/%E8%9C%98%E8%9B%9B_hu_f17d66f841bed753.jpg","permalink":"https://567liuhuaqing.github.io/p/%E6%B1%87%E7%BC%96/","title":"汇编"},{"content":"简介 自修改代码（Self-Modified Code）是一类特殊的代码加密技术，即在运行时修改自身代码或数据，从而使得程序实际行为与反汇编结果不符，同时修改前的代码段数据也可能非合法指令，从而无法被反汇编器识别，这加大了软件逆向工程的难度\n基本原理：是在编译可执行文件时，将需要加密的代码区段（如函数、代码块） 单独编译成一个section（段），并将其标记为可读，可写，不可执行，然后通过某种方法在程序运行的时候将section解密为可执行代码，并将其标记为可读、可执行、不可写，这样就不能直接在内存里面找到加密的代码，从而无法执行或修改加密的代码\nSMC的实现方式有很多种，可以通过修改PE文件的Section Header、使用API Hook实现代码加密和解密、使用VMProtect等第三方加密工具等\nSMC两种破解方式，第一种是根据静态分析结果直接修改程序二进制文件，第二种则是在动态调试时将解密后的程序从内存中 dump 下来\n编写SMC程序 一般smc程序的执行流程（假设关键函数为func）\nmain函数中获取func函数的地址 取消func函数处的页面保护 对func进行解密操作之后再调用func 为了编写smc程序，我们需要进行如下操作\n先写好func函数和main函数中的解密代码（此时不能真正解密,还需要矫正） 编译后用ida打开exe程序，找到func地址及大小，从而修正主函数的参数 用ida对func函数进行patch，保存patch后的程序 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include\u0026lt;stdio.h\u0026gt; #include\u0026lt;Windows.h\u0026gt; int func(int x, int y) { unsigned int z = 0x12345678; x = y ^ z; y = x ^ z; char flag[] = \u0026#34;helloworld\u0026#34;; printf(\u0026#34;%s\u0026#34;, flag); return x ^ y ^ z; } int main() { DWORD64 old; byte* pfunc = (byte*)func;//函数地址 VirtualProtect(func,0xE1, PAGE_EXECUTE_READWRITE, \u0026amp;old);//第二个参数为大小,可以编译后通过ida查看得到 pfunc = pfunc + *(DWORD*)(pfunc+1) + 5;//加上偏移值才是真实func地址+5是由于e9 jmp指令后的四字节是相对偏移 for (int i = 0; i \u0026lt; 0xE1; i++)//解密操作 也需要修正大小 这里是修正后的 pfunc[i] ^= 0x12; func(5, 6); return 0; } 如果直接运行该程序肯定会出错，因为此时相当于对func函数加密而非解密，所以需要用ida进行patch，idapython脚本进行patch\n1 2 3 4 5 6 7 import idc import ida_bytes addr=0x140011890 for i in range(0xe1): tmp=idc.get_wide_byte(addr) ida_bytes.patch_byte(addr,tmp^0x12) addr=addr+1 记得保存patch后的程序，再用ida打开patch后的程序，在解密func函数可用脚本解密或下断点动调观察\n测试patch后的程序 解密前的func函数，无法正常识别\n解密后的func，ida重新识别可反编译\n参考 smc动态加密技术\n风信子培训smc\n","date":"2025-03-12T22:35:59+08:00","image":"https://567liuhuaqing.github.io/p/smc%E8%87%AA%E4%BF%AE%E6%94%B9/%E5%89%AA%E5%88%80_hu_693e7fae84ce8950.jpg","permalink":"https://567liuhuaqing.github.io/p/smc%E8%87%AA%E4%BF%AE%E6%94%B9/","title":"SMC自修改"},{"content":"简介 花指令（junk code）是一种专门用来迷惑反编译器的指令片段，这些指令片段不会影响程序的原有功能，但会使得反汇编器的结果出现偏差，从而使破解者分析失败。比较经典的花指令技巧有利用 jmp 、call、ret 指令改变执行流，从而使得反汇编器解析出与运行时不相符的错误代码\n铺垫 反汇编算法 线性扫描 从程序入口点开始遍历一整个代码端，逐行对命令进行反汇编\n缺点：在冯诺依曼体系结构下，无法区分数据与代码，从而导致将数据解释为指令操作码\n递归下降 从程序入口点开始读取机器码进行反汇编，通过程序控制流来确定汇编的下一条指令，遇到无条件跳转直接跳转，遇到条件跳转则从两个命令执行分支处进行解析（优先解析顺序执行分支）\n常用花指令硬编码 硬编码：汇编指令对应的机器码，通常以16进制表示\n1 2 3 4 5 6 7 8 9 10 11 addr: 汇编指令跳转的目标地址 immedn: 目的地址与当前指令下一条指令地址的距离, 是一个偏移值 nop ----\u0026gt; 90 //1字节指令,空指令 call addr ----\u0026gt; E8 immed32 //5字节指令，immed32为4字节 call far ptr addr ----\u0026gt; 9A immed48 //7字节指令，immed48为6字节 jmp short near ptr addr ----\u0026gt; EB immed8 //2字节指令,immed8为1字节 jmp near ptr addr ----\u0026gt; E9 immed32 //5字节指令 jmp far ptr addr ----\u0026gt; EA immed48 //7字节指令 loop near ptr addr ----\u0026gt; E2 immed8 //2字节指令 ret ----\u0026gt; C2 n16 //3字节指令 等价于pop n和pop eip retn ----\u0026gt; C3 //1字节指令 等价于pop eip 两大分类 可执行花指令 可执行花指令指的是花指令代码在程序的正常执行过程中会被执行，但执行这些代码没有任何意义，执行前后不改变任何寄存器的值，同时这部分代码也会被反汇编器正常识别，其目的依然是加大静态分析的难度，让你难以识别代码的真正意图，有时这种花指令可以破坏反编译的分析，使得栈指针在反编译引擎中出现异常\n压栈后恢复栈地址 1 2 3 4 _asm { push eax; add esp, 4; } call\u0026amp;ret构造 1 2 3 4 5 6 7 8 9 10 _asm { call label label: add dword ptr ss : [esp], 7;//注意变长指令 ret } real_code //特点: 可执行花指令,最终会跳转至real_code标签处执行 //call指令本质是push nextcode和jmp desAddr，ret指令本质是jmp [esp]和sub esp,4 //在ret和real_code中间可以任意插入花指令，但要根据插入字节数添加对应add值 所以也可以通过push和jmp配合实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 _asm { push eax push ecx jmp label_1 label_2: mov eax,[esp] add [esp],8 jmp eax label_1: call label_2 pop eax } printf(\u0026#34;Hello world!\\n\u0026#34;); 通过压栈、退栈和跳转混淆代码，IDA将退栈指令识别为破坏堆栈平衡而报错，识别这类花指令后，将跳转和无效压栈等操作指令全部NOP掉即可\n混淆特征码 如下一些指令功能可以用替代指令完成，目的即增加反汇编分析的复杂程度：\n1 2 3 4 mov op1,op2 ----\u0026gt; push op2 / pop op1 jmp label ----\u0026gt; push label / ret call label ----\u0026gt; push label_next_instruction / push label / ret push op ----\u0026gt; sub esp,4 / mov [esp],op 永真条件跳转 可见后文\n不可执行花指令 不可执行花指令就是在程序执行过程中不会被执行，但利用静态分析算法的缺陷使反汇编分析执行会出错的垃圾数据，就会导致解析错误，这时我们需要跳过这些花指令才能保证程序正常运行\n简单e8跳转 简单的花指令0xe8是跳转指令，可以对线性扫描算法进行干扰，但是递归扫描算法可以正常分析\n1 2 3 4 5 _asm { jmp label1 _emit 0xe8 label1: } OD还是能被骗过去，但是因为ida采用的是递归扫描的办法所以能够正常识别\njz和jnz条件跳转 利用jz和jnz的互补条件跳转指令来代替jmp，两个跳转一个指向无效数据，一个指向正常数据来干扰递归扫描算法即ida不能正常识别\n1 2 3 4 5 6 7 8 _asm { jz lable2 jnz lable2 _emit 0xe8 lable2: } //特点: 不可执行花指令，无论是jz还是jnz指令，最终都跳转至label //在jnz label和label之间可以插入任意花指令 将这类花指令NOP即可，也可以将条件跳转指令换成无条件跳转jmp，此时ida反编译就不会报错，原理可分析递归下降算法\n永真条件跳转 通过设置永真或者永假的，导致程序一定会执行，由于ida反汇编会优先反汇编接下去的部分（false分支），也可以调用某些函数会返回确定值，来达到构造永真或永假条件\n1 2 3 4 5 6 7 8 9 10 11 12 13 _asm{ push ebx xor ebx,ebx test ebx,ebx jnz label1 jz label2 label1: _emit junkcode label2: pop ebx //需要恢复ebx寄存器 } //特点: 可执行花指令,有2条跳转分支,但只有一条分支为永真会被执行,另一条永假不执行 //在虚假分支处可以插入任意花指令 破坏堆栈平衡 汇编中函数如果有参数或局部变量，在调用前会对堆栈进行保护 ，在返回前要还原函数调用前的堆栈，这一过程程序在编译时会自动加上，如果反编译器检测到指令破坏了堆栈平衡，即函数返回时与调用时堆栈状态发生了变化，就会报错，可以利用这一点构造破坏堆栈平衡的花指令\n1 2 3 4 5 6 7 8 _asm { test eax,0 // 构造必然条件实现跳转，绕过破坏堆栈平衡的指令 jz label add esp,0x1 label: } printf(\u0026#34;Hello World!\\n\u0026#34;); //不可执行花指令 这类破环堆栈平衡的指令实际不会执行，但是由于IDA在反汇编分析时会分别从两个条件跳转处开始分析，因此判定堆栈不平衡导致反汇编失败，解决方法是NOP掉破坏堆栈平衡的指令\n参考 花指令总结\n逆向基础花指令\n恶意代码分析\n","date":"2025-03-12T15:19:48+08:00","image":"https://567liuhuaqing.github.io/p/%E8%8A%B1%E6%8C%87%E4%BB%A4%E6%94%BB%E5%85%8B/%E8%9D%B4%E8%9D%B6_hu_610be22edafe865e.jpg","permalink":"https://567liuhuaqing.github.io/p/%E8%8A%B1%E6%8C%87%E4%BB%A4%E6%94%BB%E5%85%8B/","title":"花指令攻克"},{"content":"目录\n[ 工具附件](# 工具附件)\n.py文件和.pyc文件\n[ 提取.pyc文件](# 提取.pyc文件)\npycdc反编译 pycdas查看字节码\n举个例子\n工具附件 DIE查壳工具 根据自己电脑选择win64位\n编辑\n链接：python逆向附件 提取码：1013\n.py文件和.pyc文件 ​ 首先，我们来认识一下.py文件和.pyc文件 ​ .py文件是python的源代码文件，也就是你写的源代码存放的地方。机器是无法直接读懂你写的源代码的，于是当你运行一个 Python 程序时，Python 解释器会将源代码编译成一种称为字节码的中间形式，然后将字节码存储在.pyc文件里面，当你下次再运行同样的程序时，机器会直接找到之前生成的.pyc文件进行加载。 ​ .pyc文件，是源代码经过编译后的一种中间表示形式。它无法双击直接运行，并且需要依赖特定的python环境（一个版本的python生成的pyc文件可能其他版本不能使用）所以它并不是可执行文件。它的存在仅仅是为了加快程序执行效率，避免重复编译。 这样就引来了一个问题——它不能像C一样自动生成一个可执行文件，如若要使用，则必须下载python环境并运行源代码，这样做非常依赖环境。 ​ 于是python提供了PyInstaller这个库，它可以将.py文件转为.exe文件，这样产生的.exe文件在没有Python环境时也可以直接使用。 ​ 一般的.py转成的.exe文件长这样:\n编辑\n我们可以用DIE打开看到为python语言写的\n编辑\n提取.pyc文件 ​ 第一步，将.exe转化成.pyc文件 ​ 使用工具pyinstxtractor.py提取.pyc文件 ​ 使用方法：在该pyinstxtractor.py文件所在目录打开终端，输入\n1 python pyinstxtractor.py [文件完整路径] ​ 这条指令的意思是用python解释器运行pyinstxtractor.py脚本，并把这个.exe文件作为参数传入。 ​ 输入完成后文件目录下会出现一个文件名_extracted文件夹\n编辑\n​ 打开这个文件夹，找到里面与.exe文件同名的.pyc文件\n编辑\npycdc反编译 ​ 上一步得到.pyc文件后，我们需要使用工具来查看源代码。 ​ 这里有两种方法，第一种是用pycdc反编译：将.pyc文件与pycdc放于同一个目录，打开终端，输入\n1 pycdas(.exe) [文件名] #括号内的部分可省略 ​ 这个指令就是把文件当参数传入，然后运行pycdc.exe，它就会把字节码反编译为源码。 ​ 但这个工具有时候不能反编译出所有的代码，这时我们就要用到另一种工具：pycdas\npycdas查看字节码 ​ 当pycdc反编译不完全时，就需要使用pycdas。 ​ .pyc文件是二进制文件，无法直接打开查看内容，而pycdas则可以帮助我们查看.pyc文件里面的字节码。 ​ 使用方法与pycdc相同：将.pyc文件与pycdas放于同一目录，然后打开终端，输入\n1 pycdas(.exe) [文件名] #括号内的部分可省略 有时python版本太高，反编译不出python源码\n使用python解释器调用dis解释出pyc文件的字节码\n1 2 3 4 5 6 7 import marshal import dis f=open(r\u0026#39;easyRE.pyc\u0026#39;,\u0026#39;rb\u0026#39;) # 将pyc文件和该脚本放于同一文件夹内,或者自行指定绝对路径 code=marshal.loads(f.read()[16:]) print(dis.dis(code)) f.close() ​ 相应工具以上传至文章顶部\n举个例子 将题目附件拖进DIE查壳，可发现为python可执行文件\n编辑\n在pyinstxtractor.py文件所在目录打开终端，输入\n1 python pyinstxtractor.py [文件完整路径] 提取.pyc文件，出现以下界面\n编辑\n在文件目录下出现test.exe_extracted文件夹\n编辑\n在这个文件夹里面找到与.exe文件同名的.pyc文件\n编辑\n将改.pyc文件与pycdc放于同一个目录，打开终端，输入\n1 pycdc test.exe 可以看到python源码\n编辑\n易知为base64解密，可以写脚本，也可以用工具\n编辑\n得到flag{Reverse_python}\n备注例题也以上传\n","date":"2025-02-27T22:50:04+08:00","permalink":"https://567liuhuaqing.github.io/p/python_rev/","title":"Python_Rev"},{"content":"HelloBlog ","date":"2025-02-27T10:55:18+08:00","image":"https://567liuhuaqing.github.io/p/myfisrtblog/%E5%BA%93%E6%B4%9B%E7%B1%B3%E5%A0%86%E7%B3%96_hu_3fd1b0f24221433e.jpg","permalink":"https://567liuhuaqing.github.io/p/myfisrtblog/","title":"MyFisrtBlog"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://567liuhuaqing.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu_2307260c751d0e0b.jpg","permalink":"https://567liuhuaqing.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://567liuhuaqing.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu_e95a4276bf860a84.jpg","permalink":"https://567liuhuaqing.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://567liuhuaqing.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu_c1ca39d792aee4ab.jpg","permalink":"https://567liuhuaqing.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$","date":"2019-03-08T00:00:00Z","permalink":"https://567liuhuaqing.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://567liuhuaqing.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu_27b8954607cdb515.jpg","permalink":"https://567liuhuaqing.github.io/p/emoji-support/","title":"Emoji Support"}]